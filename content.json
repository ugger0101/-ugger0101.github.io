{"meta":{"title":"codeforce","subtitle":"codeforce","description":"","author":"CXQ","url":"https://www.codeforce.top","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2020-06-28T13:54:20.303Z","comments":true,"path":"404.html","permalink":"https://www.codeforce.top/404.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2020-06-28T13:51:03.087Z","comments":true,"path":"categories/index.html","permalink":"https://www.codeforce.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-06-28T13:50:47.825Z","comments":true,"path":"tags/index.html","permalink":"https://www.codeforce.top/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-06-28T13:52:01.479Z","comments":true,"path":"about/index.html","permalink":"https://www.codeforce.top/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2020-06-28T13:52:22.115Z","comments":true,"path":"friends/index.html","permalink":"https://www.codeforce.top/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"软件体系结构（4）","slug":"软件体系结构（4）","date":"2020-12-28T06:41:39.000Z","updated":"2020-12-28T13:23:08.053Z","comments":true,"path":"2020/12/28/ruan-jian-ti-xi-jie-gou-4/","link":"","permalink":"https://www.codeforce.top/2020/12/28/ruan-jian-ti-xi-jie-gou-4/","excerpt":"","text":"软件设计体系（4）设计原则 软件设计原则是设计的指导方针，原则的遵循可以避免出现糟糕的设计 OO设计原则SRP - 单一职责原则 每个类应该有一个责任，这个责任应该由类完全封装 原则：一个类只有一个改变的理由 职责：改变的理由 如果一个类有多个职责，那么职责就会彼此耦合。 如果模块具有多个职责，内聚性就低。 良好设计的内聚性应该很高 内聚性衡量一个模块中的源代码行如何协同工作以提供特定功能的指标。面向对象编程中，内聚性指方法实现单一功能的程度。 实现单一功能的方法具有高内聚性 低内聚的表现、特点 一个类的方法很少相关。 方法执行不相关的活动，通常使用不相关的数据集 低内聚性的特点： 模块理解困难 系统维护困难 模块重用困难 例子 OCP -开闭原则软件实体是可扩展,而不可修改的 这意味着需求发生发化时，以对原有设计进行扩展方式应对，而不是以修改原有代码的形式应对 开闭原则 对扩展是开放的 -添加新功能 对更改时封闭的 -现有代码未更改 OCP无法对所有的需求变化进行封闭 扩展点需要进行选择 仅适用于实际需求变化 违反OCP原则的例子 刺激变化 先写测试。 使用较短的开发周期 先开发核心功能并经常向涉众展示这些功能 首先开发最重要的功能。 尽早且经常发布软件。 实现 对可能发生变化的部分进行抽象 使用多态来添加不同的行为 抽象也可以应用于非OO语言！ LSP -里氏替换原则通过继承实现抽象和多态性设计中的静态结构改为动态结构，维持设计的封闭性 LSP：子类型必须可以替换其基类型 继承关系无法孤立地去验证 行为上，正方形不是矩形 DIP -依赖倒置原则原则 高层模块不应该依赖低层模块， 两者都应该依赖抽象 抽象不应该依赖细节，细节应该依赖抽象 结构化分析与设计往往造成高层模块依赖低层模块，策略依赖细节实现 一般来说，高层模块包含应用程序的商业决策和业务模型 取决于抽象 DIP原则的核心是：应该只依赖抽象，即抽象类和接口 这种假设过于严格，对于不容易变化的类，并不需要使用抽象 抽象应该用到系统的易变化部分，以及需要进行解耦的部分，譬如：层之间 总结 ISP - 接口分离原则原则客户程序不应该被迫依赖其不使用的方法，客户程序彼此独立 消除多职责的类（接口不内聚的类） 将“胖”接口分解成多个接口，每个接口服务特定类型的客户程序。 包定义 包用来对类分组 系统中，有些类互相依赖即相互协作完成特定功能。 系统中，有些类不知道彼此 将有关系的类放在一个包里很自然 什么样的类应该放在一个包里?请见这里 包之间的依赖关系是什么样的？请见这里 包的内聚性原则重用发布等价原则 重用粒度与发布粒度等价 共同重用原则 包中的类一起重用。 如果你重用包中一个类，则要重用包中所有的类。 一个包中的类彼此依赖。没有关系的类不应该放在同一个包中 共同封闭原则 一个包中的所有类应该对同一种需求变化封闭。影响包的变化影响包中所有的类，但不影响其他包。 一个包不应有多个变化的原因。 包的耦合度原则无环依赖原则（ADP） 在包依赖关系图中不允许环存在 解决方案 每周构建 所有的开发人员在每周的前四天工作于自己的代码库，不需要对彼此的代码集成。 周五，整合开发的所有代码并建立系统 适用于中型项目 ADP 将开发环境划分为可发布的包 为了采用自底吐上增量式开发，不允许环存在 有向无环图（DAG, Directed Acyclic Graph）：无论从哪个包开始，都不可能沿着依赖关系回到起点包。这种结构没有环 解除环并将依赖关系图恢复为有向无环图DAG的两种方案 应用依赖倒置原则 创建一个MyDialog和MyApplication都依赖的新包。 稳定依赖原则（SDP） 顺着稳定的方向依赖 SDP原则可以确保不稳定的模块依赖稳定的模块 稳定性度量$$I=\\frac {C_e}{C_a+C_e}$$ $$C_a:包外依赖于包内部类的类的数量$$ $$C_e:包内依赖于包外部类的类的数量$$ $$I:不稳定度$$ I=0 表示最稳定的包 I=1 表示最不稳定的包 不是所有的包都应该稳定 稳定抽象原则（SAP） 稳定的包应该是抽象的 一个稳定的包也应该是抽象的，其稳定性不应该妨碍它被扩展 SAP和SDP合起来等同于包癿DIP原则 测量抽象 $$A = \\frac {N_a} {N_c}$$ $$N_c:包中类的数量$$ $$N_a:包中抽象类的数量$$ A : 抽象度","categories":[],"tags":[]},{"title":"软件体系结构（3）","slug":"软件体系结构（3）","date":"2020-12-28T06:39:04.000Z","updated":"2020-12-28T06:39:19.554Z","comments":true,"path":"2020/12/28/ruan-jian-ti-xi-jie-gou-3/","link":"","permalink":"https://www.codeforce.top/2020/12/28/ruan-jian-ti-xi-jie-gou-3/","excerpt":"","text":"软件体系结构（3）质量属性 属于非功能性需求，并不被功能所决定 实现功能特性必项给构成系统中的各个部分（模块） 赋予正确的职责、正确的资源和正确的调度顺序 先实现功能，再谈质量属性（与架构选型有关） 不同的软件项目，关注不同的质量属性 影响体系结构风格的选择 质量属性之间可能互相抑制 优先保证高优先级的质量属性 影响有时是正面的，有时是负面的，比如 组件粒度大会提高性能，但会降低可维护性 常见质量属性可用性定义： 当用户使用系统时，系统可用的概率 提前确定的停机维护不计入 大部分IT系统的关键需求 与系统故障和故障导致的结果相关 与应用程序的可靠性相关 关注点 系统故障如何被检测到（比如无法提供正常的服务，被外界发现） 系统故障发生的频率 系统故障的后果 系统故障时会发生什么 允许系统停止运行多长时间 故障如何被避免 故障发生时需要什么类型的通知 场景 刺激源 故障的迹象（来自内部或外部） 刺激 系统出错 系统崩溃（反复出错） 给出结果不准时（早或晚） 给出错误结果 制品 计算或存储或网络传输 环境 正常状态或”亚健康“状态 响应 记录日志（错误报告），回传给厂家 通知管理员或其他系统 关闭系统，系统在维修期间不可用 响应衡量指标 故障时间百分比、修复故障所需时间、平均无故障时间…… 场景实例 提高可用性策略策略定义 满足特定质量属性的具体设计手段 是体系结构风格的基本单元 概述 目标 降低故障造成的影响 方向一:故障检测 如何第一时间发现故障 方向二：故障恢复 如何恢复正确的结果 方向三：故障避免 如何主动减少故障的发生 故障检测 Ping/echo 监控组件不定期吐被监控组件发出ping消息，并根据收到的echo消息（是否收到、延时）做出响应 Heartbeat（心跳） 被监控组件定期向监控组件发出心跳消息 在节点间保持周期性的心跳信号以检测各个节点的状态。若连续未收到的心跳信号到了一定的数目，就认为相应的系统已经出现故障。 Exceptions 抛出 + 捕获 + 处理 需要编程语言支持 故障恢复 投票 多个冗余的组件，用统一或不同癿算法来完成同一个任务。如果计算结果不同，则少数服从多数 为降低同时出错的概率，多个组件可以由不同的开发团队在不同的软、 硬件平台上开发 主动冗余 A、B服务器完成同样的运算（A和B的状态时刻保持一致），平时只取A算出的结果 当A出现故障时，系统可以极快地切换到B 被动冗余 A服务器完成运算后的一定时间内把自身状态告知B，B再把自身状态更新为A的状态 当A出现故障时，首先需要确认B的状态是最新的 在重新上线前，都需要做状态的重新同步 内测 开发人员修正bug，并在内部进行测试，确认无误后再发布补丁 检查点/回滚 定期保存，便于恢复 故障避免 服务下线 惹不起，躲得起 如果明确知道即将遭到毁灭性攻击，不如主动下线 事务 多个操作必须全部完成 进程监控 Windows任务管理器 是否有进程停止响应 易用性关注点涉及用户完成任务务的容易程度以及所提供的用户支持类型 场景 刺激源 终端用户 刺激 终端用户希望学习系统的使用、提高系统使用效率、减少出错… 制品 整个系统 环境 系统处于运行时或配置时 响应 系统响应用户的要求 响应衡量指标 用户完成任务的时间 用户出错的次数 用户满意度 用户操作的成功率 场景实例 提高易用性策略概述 目标 让用户轻松 方向1：运行时策略 方向2：设计时策略 运行时策略 系统猜测用户要完成的任务 输入法联想、搜索引擎联想 系统给用户适当的反馈 提示拷贝文件所需的剩余时间、浏览器打开页面的进度 支持撤销操作 减少误操作的影响 比如：回收站 还原功能 系统给用户提供一致的体验 鼠标提供DPI调整，适应不同分辨率 设计时策略 把用户界面和系统其它部分隔离开 MVC模式 支持用户界面的独立修改（甚至用户可以自行修改用户界面） 可修改性概述 在软件系统的生命周期中对其进行修改是客观存在的事实。 可修改的系统更容易演化 可修改性只考虑系统可能发生的变化，不需要考虑不太可能发生的发化 可修改性主要考虑变化的成本。 可修改性用来度量修改应用程序以满足新的功能性/非功能性需求的容易程度。 影响很难量化 评估可修改性 令人信服的需求变化的影响分析 解决方案在不进行改变癿情况下满足需求变化的证明 降低依赖性可提高可修改性 关注点 修改的成本 系统的哪些部分被修改 修改发生的时间 修改由谁来进行 衡量指标 修改完成的时间 修改所花的人力成本 修改所花的经济成本 场景 刺激源 谁进行的修改（开发者/管理者/用户） 刺激 要进行的具体修改 制品 修改系统的功能或UI或交互的其他系统 环境 在什么时间进行的修改？设计期间 or 开发期间 or 运行期间？ 修改的时间越迟，越不利 响应 操作人员要理解如何修改、进行修改操作、测试、部署 响应衡量指标 时间、成本 场景实例 提高可修改性策略概述 目标 降低修改的时间和成本 方向1：限制修改范围 让修改所影响的软件范围尽可能的小 方向2：延迟绑定时间 让软件在运行期间仍可进行灵活修改 限制修改范围 模块高内聚、低耦合 尽量把对程序的修改控制在一个模块内 可以借助框架、中间件 考虑到可能会发生的修改 有助于评估模块间责任的划分 让一个点的修改只影响一个模块 避免完全无关的多个修改会影响同一个模块 让模块通用 ”解释器“风格思路 隐藏信息 面向对象机制中的可访问性 维持接口不变 在接口不变的情况下，接口连接的双方可以独立变化 限制通信路径（将多对多转换成1对多访问） 设计模式中的Facade模式 使用中介 数据中介：共享数据的风格 服务中介:设计模式中的bridge，factory method等模式 命名服务器 查询所需资源/对象的位置，解决位置依赖 按需创建实例 借助设计模式中的创建型模式 延迟绑定时间 配置文件 修改配置文件，而不用修改代码 发布-订阅模式 软件体系风格部分已有介绍（事件系统） 设计模式中的”观察者模式“ 多态 用不同的子类，实现不同的功能 安全性概述关注点在保证合法用户使用系统的前提下，抵抗对系统的攻击 攻击（威胁）试图突破系统安全性防护的尝试，可能是非法访问数据或服务或拒绝向合法用户提供服务。 安全性的不同方面 不可否认性： 消息的发送方有发送证明且接收者确认发送者的身份。即双方都不能否认其参与信息交换的事实。 也就是说，交易不能被任意一方否认。 私密性 可用性 审计（为了重建） 系统跟踪内部活动并可进行重建 完整性 确保传输过程中不被修改 场景 刺激源 攻击可能由人或其他系统发起 刺激 对系统的攻击（或试图突破系统安全保护） 常见形式：窃取或修改信息、获取超权限的服务、降低系统可用性 制品 系统所提供的服务或系统中的数据 环境 系统可能处于不同的情况下（联网/未联网、在线/下线、 在防火墙内/外） 响应 合法用户正常使用，拒绝非法用户的使用 对攻击有威慑 响应衡量指标 发起攻击的难度 从攻击中恢复难度 场景实例 提升安全性策略概述 方向1：抵抗攻击 方向2：检测攻击 方向3：从攻击中恢复 抵抗攻击 用户的证实/授权 密码、验证码、生物识别…… 确认用户的操作是在其权限范围 维持数据的保密性 给数据和传输过程加密 维持数据的完整性 MD5码校验 减少暴露 关闭无用端口、自启动的服务、无线路由SSID等 限制访问 白名单、黑名单 检测攻击 软件和人结合 入侵检测系统 安全专家 从攻击中恢复 恢复状态 使用”可用性“中的相关策略 攻击者的识别 也能震慑潜在的攻击者 安全性示例 用户加密码 2.短信验证码 性能概述事件的来源用户的请求、本系统内部、本系统外部 事件到达模式 随机的 在特定时间尺度（日、月、学期、年）有规律的 关注点 系统响应事件的速度 和事件的数量和到达模式有关 吞吐量 应用程序在单位时间内必须执行的工作量 每秒处理的事务数量 每分钟处理的消息数 需要的吞吐量 平均值 负载峰值 响应时间 应用程序处理一个请求的延迟时间 通常以（毫）秒为单位 需要的响应时间： 最大延迟 平均延迟 截止期限 必须在某个特定时间之前完成 工资发放系统必须在凌晨两点前结束工作，以便电子转账信息能被发送到银行 每周审计必须在周一早上六点完成以便管理层可以使用数据 截止期限通常与IT系统中的批处理相联系 场景 刺激源 可能来自系统内部或外部 刺激 事件到来（需要响应） 制品 系统所提供的服务 环境 系统可能处于不同的模式（正常/紧急/超载） 响应 系统处理到来的事件，可能会导致状态的变化 响应衡量指标 处理事件所花的时间 单位时间内处理事件的数目 处理的错误率/丢失率 场景实例 提升性能策略概述 目标 在限定时间内响应事件 获取资源+使用资源 方向1：资源的需求 方向2：资源的管理 方向3：资源的仲裁 资源的需求 在要处理的数据量不变的情况下，提高计算效率 使用更高效率的算法 减少处理事件时对资源的占用 减少要处理的数据总量 控制事件到来的速率 只抽取一部分请求来处理 限制执行时间 在规定时间内得到近似解 限制待处理事件队列长度 直接放弃处理一部分事件 资源的管理 利用并发机制 多线程、多进程、多核、多机 增加可用资源 计算资源、存储资源、带宽资源 资源的仲裁 先来先服务 固定优先级调度 机场、车站的军人绿色通道 动态优先级 不饿死 最早deadline优先 可测试性概述软件测试就是为了发现错误 关注点 让软件的bug容易被测试出来 验证软件产品与它的需求规格是否匹配（存在不符或缺失） 使用最小的成本和工作量来验证软件的质量 测试的重要性 一般软件项目40%的成本花在测试上 大型软件项目出现故障，可能导致严重的后果 如果能在体系结构层面提高可测试性，收益巨大 场景 刺激源 测试可能由不同的角色发起（开发者、单元测试人员、集成测试人员、系统管理员、用户……） 刺激 系统开发到达里程碑 可能是分析/设计/编码/集成阶段的结果，或系统完成开发 制品 一个设计、一段代码、整个系统。。。 环境 系统可能处于设计阶段/开发阶段/部署阶段/正常运行时 响应 理想的响应是可以进行测试，并且可以观察到测试结果 当测试结果无法被观察到时，测试难度很大 响应衡量指标 白盒测试中的逻辑覆盖率 语句覆盖 判定覆盖/分支覆盖（判定可能是多个条件组合） 条件覆盖：覆盖判定中的每个条件 路径覆盖、判定条件覆盖、条件组合覆盖…… 未来继续发现bug的概率（估算法） 场景实例 提升可测试性策略 目标 让测试更轻松 方向1：黑盒测试 方向2：白盒测试 黑盒测试黑盒测试包括等值分析测试、错误推测法、边界值分析测试；逻辑覆盖测试属于白盒测试 记录/回放 自动化/半自动化测试 把接口和实现分离开 不同的排序算法，使用相同的接口 提供专用的测试路径 内部监控 IDE提供的断点等调试工具 WinDbg等工具 可扩展性可扩展性描述系统、网络或进程以用户可以接受的方式处理工作量的增长或能更容易地扩张 常见的可扩展性问题 请求负载 连接数 数据量 部署节点数 经常被忽视原因 不是应用崩溃主要原因 难以预测 难以测试/验证 主要依赖验证过的设计和技术 可靠性可移植性可维护性通用质量属性场景vs. 具体质量属性场景 通用质量属性场景具有系统独立性，适用于任何系统 质量属性表可充当核对清单，以确保所有可能性都被考虑到 具体质量属性场景特定于特定系统，让质量需求变得可操作 具体质量属性场景特征： 具体场景集合可用作系统的质量属性需求 每个场景必须足够具体才对架构师有意义 响应细节足够具体以便测试系统是否满足质量属性 从不同质量属性可能会生成相同或相似的场景，冗余质量属性可容易地被删除。重要的是没有重要的需求被遗漏。 质量属性场景组成部分 质量属性场景是一个质量属性特定的需求。 描述系统如何对刺激做出反应。由六部分组成： 刺激源：谁造成的刺激 刺激：影响系统的事件 制品：系统被影响的部分 环境：刺激发生时系统所处的状态 响应：刺激所产生的结果 响应衡量指标：如何评估响应，响应发生时应当以某种方式进行度量以测试需求是否被满足。","categories":[],"tags":[]},{"title":"软件体系结构（2）","slug":"软件体系结构（2）","date":"2020-12-28T06:38:34.000Z","updated":"2020-12-28T13:11:42.629Z","comments":true,"path":"2020/12/28/ruan-jian-ti-xi-jie-gou-2/","link":"","permalink":"https://www.codeforce.top/2020/12/28/ruan-jian-ti-xi-jie-gou-2/","excerpt":"","text":"软件体系结构（2）==软件体系结构风格==1.定义描述特定领域中软件系统家族的组织方式的惯用模式 (idiomatic paradigm)，反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组细成一个完整的系统。（不是统一的，包含各个流拍对软件体系结构的定义） 2.分类 数据流体系结构风格理解： 处理：==数据到达即被激活==，没有数据就不工作 举个例子：Excel中改变某个单元格的值，则依赖于该单元格的其他单元格的值也会随之改变 特征： 数据的可用性决定着处理&lt;计算单元&gt;是否执行 系统结构由数据在各处理之间的有序移动决定 在纯数据流系统中，处理之间除了数据交换没有任何其他的交互 基本构件：数据处理​ 构件接口：输入端口和输出端口 ​ 计算模型：从输入端口读数，经过计算/处理，然后写到输出端口)到另一个处理的输入端口 连接件：数据流​ 单吐、 通常是异步、有缓冲 ​ 接口角色：reader和writer 计算模型: 把数据从一个处理的输出端口传送到另一个处理的输入端口 批处理体系结构风格直观结构 定义：基本构件：独立的应用程序 连接件：某种类型的媒质（磁带） 连接件定义相应的数据流图，表达拓扑结构 每个处理步骤是一个独立的程序 每一步必项在前一步结束后才能开始 数据必项是完整的，以整体的方式传递 应用实例： 管道-过滤器体系结构风格直观结构： 定义：场景：（数据产生-&gt;系统处理）数据源源不断的产生，系统需要对这些数据进行若干处理(分析、计算、转换等) 递增的读取和消费数据流,数据到来时便被处理，不是收集然后处理，即在输入被完全消费之前，输出便产生了 原理：每个处理步骤(过滤器)都有一组输入和输出，过滤器从管道中读取输入的数据流，经过内部处理，然后产生输出数据流并写入管道中。 构件过滤器（独立的实体），处理数据流 一个过滤器封装一个处理步骤 数据源点和数据终止点可以看作是特殊的过滤器 连接件管道，连接一个源和一个目的过滤器 过滤器目标：将源数据变换成目标数据 过滤器对数据流的五种变换类型 语义约束：是独立的实体 无上下文信息 不保留状态 对其他过滤器无任何了解 管道：​ 将数据从过滤器的输出移动到过滤器的输入（或设备或文件） 单向流 可能具有缓冲区 管道形成传输图 不同的管道中流动的数据流，可能具有不同的数据格式，数据在流过每一个过滤器时，被过滤器进行了丰富、精练、转换、融合、分解等操作，因而发生了变化。 管道/过滤器模式：组件：过滤器 - ==处理数据== 从输入读取数据流并输出数据流 连接器：管道 – ==数据翻译与传输== 将过滤器的输出数据传送给其他过滤器 拓扑结构: 线性 变种：反馈循环，分裂管道 它们不共享状态 它们不知道其前任/后继 编译器： 优点： 高内聚：过滤器是执行特定功能的自包含处理服务，具有较强的内聚性 低耦合: 过滤器间仅通过管道通信 可重用: 支持过滤器的重用 可简单地实现为并发或顺序系统 可扩展性：容易添加新的过滤器 灵活性： 过滤器功能可重新定义 线路可改变 缺点： 管道中数据传输需要公共格式 难以支持基于事件的交互 不适合处理交互的应用： 在早期对交互应用需求不高的情况下提出 当需要增量地显示改变时，这个问题尤为严重 系统性能不高，并增加了编写过滤器的复杂性 数据传输缺乏通用标准，每个过滤器都增加了解析和合成数据的工作 绝大部分处理时间消耗在格式转换上 不适用于需要大量共享数据的应用设置 批处理 VS 管道-过滤器把任务分解成为一系列固定顺序的计算单元 &amp; 彼此间只通过数据传递交互。 数据为中心体系结构风格定义以数据为中心体系风格引入一个共享数据源，用来进行数据交换。 例子：注册表 剪贴板 仓库体系结构风格仓库是存储和维护数据的中心场所 两种不同的部分组成（构件）： 中心数据结构，表示当前数据的状态 一组对中心数据进行操作的独立构件 连接件仓库与独立构件之间的交互 存在两种交互机制数据库方式：输入流中的事务类型触发需要执行的过程（被动驱动） 黑板结构：中心数据结构的当前状态触发并选择需要执行的过程（主动驱动） 适用场景：适用于中心问题是建立、扩充和维护复杂的中心信息体的应用程序 应用场景：数据处理，软件开发环境（典型应用：数据库） 应用实例传统编译器结构：批处理/管道-过滤器 传统带符号表编译器结构具有共享的符号表 很多信息在编译过程中可能会被多个阶段的编译程序所使用 现代的规范编译器结构带符号表与语法树 (parse tree)的编译器。 黑板体系结构（保存求解状态）概述： 下图为重点了解 定义：黑板结构：中心数据结构的当前状态触发并选择需要执行的过程 黑板系统的基本结构 全局数据库，用来存储数据、传递信息，包含解域的全部状态 解决问题过程中的状态数据，以层次形式组织起来 知识源对黑板进行修改，逐渐找到问题的解 各知识源之间的通讯和交互只通过黑板进行 知识源知识源是描述某个独立领域问题的知识及其处理方法的知识库 ，其分别存放且相亏独立的，通过黑板进行通讯，合作求出问题的解，通常知识源具有“条件-动作”的形式。当条件满足时，知识源被触发，其动作部分增加或修改黑板上的内容。 Control控制器 应用：人工智能(Artificial Intelligence, AI)领域典型应用领域：自然语言处理、语音处理、模式识别、图像处理等； 应用实例 调用/返回体系结构主程序/子程序风格 单线程控制，划分为若干处理步骤 功能模块：把步骤集成至模块中 抽象数据类型（ADT） 操作和数据绑定在一起，隐藏实现和其他秘密 面向对象 方法（动态绑定），多态（子类），重用（继承） 对象活动于不同的进程/线程（分布式对象） CS结构、分层风格 组件 多个接口，二进制兼容，高级中间件 主程序与子程序该模式适合计算过程符合层次化结构，功能逐级细分的特征 许多编程语言天然地支持层层嵌套过程调用并可用层次化对它进行管理和调用，使得每一模块具有命名空间，这种执行环境在单一命名空间提供单线程控制，拥有自己的变量和方法 系统模型：层次化调用，子系统通过模块化定义 组件：数据和可访问功能可见 连接件：通过过程或函数调用，传递参数捕获返回值 控制结构：单线程 数据抽象/面向对象系统模型：局部化状态的维持 组件：不同角色比如servers、对象、抽象数据类型 控制结构：分布式或去中心化结构，单线程 元素： 封装：限制对某些信息的访问 交互：通过过程调用或类似的协议 多态：在运行时选择具体的操作 继承：对共享的功能保持唯一的接口 复用和维护：利用封装和聚合提高生产力 风格变种：C/S结构： 主要组成部分：数据库服务器、客户应用程序和网络 服务器（后台）负责数据管理，客户机（前台）完成不用户的交互任务。 进程就是对象 不对称：客户端知道服务器，反之则不然 缺点： 对客户端软硬件配置要求较高，客户端臃肿 客户端程序设计复杂 数据安全性不好。客户端程序可以直接访问数据库服务器 信息内容和形式单一 用户界面风格不一，使用繁杂，不利用推广使用 软件维护与升级困难。每个客户机上的软件都需要维护 演变——三层CS风格： 与二层相比，增加了一个应用服务器 整个应用逻辑驻留在应用服务器上，叧有表示层存在于客户机上 应用功能分为表示层、功能层、数据层三层 表示层是应用的用户接口部分，通常使用图形用户界面 功能层是应用的主体，实现具体的业务处理逻辑 数据层是数据库管理系统 以上三层逻辑上独立。 BS风格： 层次化： C/S模式的扩展 运行时层的结合 通常只有少量的层 组件化： 多接口 支持动态配置的专门协议 层次结构案例： 该模式适合于问题可以很自然地分解/组织为层次结构，基本系统级别—上层应用或特殊任务的应用 具有相同业务的类组织成一个层，通过人为设计分解为层次结构完成系统功能设计 系统模型：不透明的层次，可提供服务 组件：功能的集合，一般操作或是函数调用 连接件：依赖组件结构，过程调用 控制结构：单线程 特点： 每层为上一层提供服务，使用下一层的服务，只能见到与自己邻接的层（可越层操作） 大的问题分解为若干个渐进的小问题，逐步解决，隐藏很多复杂度 修改一层，最多影响两层，而通常只能影响上层。接口稳固，则谁都不影响 上层必须知道下层的身份，不能调整层次之间顺序 层层相调，影响性能 虚拟机体系结构风格解释器：该模式适用于大多数编程语言或机器不能直接支持的系统，核心问题是定义一个解决方案的表达方式，即系统软硬件底层无法支持业务应用系统就架设一个虚拟机系统以满足需求 解释器通常被设计为执行环境已支持的机器或语言与期望机器或语言的桥梁 组件：一个状态机器（执行引擎）和三个存储（执行引擎当前状态、被解释问题、被解释问题当前状态） 重要变种：专家系统 优点： 仿真硬件不具有的功能 （仿真原生系统） 可仿真“灾难”模式测试（关键应用的安全性） 多功能工具 缺点： 比硬件慢 比编译系统慢 额外增加一个需要验证的软件层 规则系统风格 规则引擎：Drools 事件系统特点： 事件的触发者并不知道哪些构件会被这些事件影响，相互保持独立。 不能假定构件的处理顺序，甚至不知道哪些过程会被调用。 各个构件之间彼此之间无连接关系，各自独立存在，通过对事件的发布和注册实现关联。 基本结构与工作原理 基本结构 事件源 事件处理器 事件管理器 基本构件 过程或函数，充当事件源或事件处理器的角色 事件 连接机制 应用实例： 调度机制 体系结构评估 必要性：目标：得到更好的软件体系结构，或提高人们对于软件体系结构的信心 使利益相关人员在一起充分交流 强制与特定质量目标的结合 生成冲突目标的优先级 对软件体系结构给出一个清晰的说明 提高软件体系结构文档的质量 发现跨顷目复用的机会 得到优化后的软件体系结构实践 定义：结构评估是软件开发过程中一个重要环节，是若干项目干系人对于软件架极能否满足需求进行的正式或非正式的活劢，返些活动会运用一些技术比如基于场景的技术比如ATAM。 原因 越早发现问题软件成本越低 验证需求是否满足 揭示冲突和平衡 验证的准备可能会暴露一些问题 评估方法SAAM： 最早的软件体系结构分析文档 分析非功能性需求 基于项目干系人生成的场景分析结构 ATAM： SAAM的继承 更注重质量属性间的影响冲突 聚焦可修改性 性能 可用性 安全性 发现结构化设计潜在问题 折衷显示发现并文档化 减轻活动风险：比如未来设计、分析以及原型开发（设计） 目标 发现因体系结构设计存在的风险而非详尽精准分析 发现趋势：正确的体系结构设计和一些系统本身需要的质量属性之间有没相互矛盾的 好处 识别风险 阐明质量属性需求 提升体系结构设计及设计文档化 增强项目干系人之间的交流沟通 提升系统架构 评估阶段阶段0技术准备阶段： 评估内容 团队内评估方法的交流 制定评估协议 核心评估尚未开始 阶段1it呈现详细架构信息及简单分析 以技术相关人员为主的团队 以架构为中心 自顶向下分析过程 1.评估负责人给召集在一起癿利益相关人员介终ATAM方法 技术： 效用树产生 架构评估分析 场景头脑风暴 输出： 架构方法 效用树和场景 风险，无风险，敏感点及折衷 2. 功能需求 质量属性需求 架构驱动 关键需求 3.结构师简要描述架构设计 描述OS 硬件 中间件 与其它系统交互情况 实现质量属性策略 4.架构核心方法 5.明确描述质量属性目标是否满足 优先级定义 建立效用树刻画重要质量属性目标 效用树示例： 6.判断步骤4得到的体系结构方案是否满足步骤5得到的质量需求 确定架构方法 针对最高优先级的场景，提出特定于质量属性的问题 识别并记录风险和非风险、敏感点和权衡 阶段2 加入项目干系人 以干系人为中心 聚焦以项目干系人视角验证第一阶段结果 利用头脑风暴形成场景 效用树leaves场景验证phase1 7.利益相关人员生成一组感兴趌癿场景，可能不效果树中不同；场景类型：用例场景、成长场景、探索场景； 划分场景优先级 8.解释相关软件体系结构决策如何有助于场景实现 用新场景验证第六步（阶段一） 进一步指明 进一步检验系统架构信息 9.整体概括和总结输出 架构设计 效用树 场景 有风险 无风险 敏感点 权衡点 风险主题分析 阶段3主要包括为客户制作最终报告，以及反映评估和ATAM材料的质量 敏感点 对于实现QA是非常关键的部分 加密位数对于加密级别是敏感点 权衡点 影响两个及以上不同质量属性，对多于一个以上QA是敏感点 加密级别的改变 安全 性能 风险决策风险是一个潜在的有问题的架构决策 无风险决策需求被满足了 好的架构设计 阶段 小结 ATAM关注多质量属性 发现体系结构结果的有效策略 非详尽精准分析","categories":[],"tags":[]},{"title":"软件体系结构（1）","slug":"软件体系结构（1）","date":"2020-12-28T06:32:04.000Z","updated":"2020-12-28T09:27:13.093Z","comments":true,"path":"2020/12/28/ruan-jian-ti-xi-jie-gou-1/","link":"","permalink":"https://www.codeforce.top/2020/12/28/ruan-jian-ti-xi-jie-gou-1/","excerpt":"","text":"软件体系结构软件的定义计算机软件 = 程序 + 数据 +文档 软件体系结构的定义软件体系结构=组件+连接件+约束 组件：具有某种功能的可重用的软件模块单元，表示系统中主要的计算单元和数据存储 连接件：表示组件之间的交互，简单的连接件有：管道、过程调用 、事件广播等 约束：表示组件和连接件的拓扑逻辑和约束。 软件体系结构的内容 体系结构是软件系统的抽象描述，是需求到实现的桥梁。 体系结构的设计方法： 通过一系列设计活动获得满足系统功能性和非功能性需要的模型 体系结构的分析方法 基于形式化方法、数学模型和模拟技术得出量化分析结果 基于调查问卷、场景分析、检查表等手段侧重可维护性、可复用性等难以量化的质量属性 体系结构的复用 代码复用 设计复用 过程复用 软件工程的目标和原则目标：可修改性，有效性，可靠性，可理解性，可维护性，可复用性，可适应性，可移植性，可追踪性 原则： 软件工程三要素 软件生存周期 软件结构有关概念 软件开发模型 瀑布模型 带反馈的瀑布模型 V模型 快速原型模型 迭代模型 并行模型 螺旋模型 螺旋模型是瀑布模型和原型模型的有机结合 敏捷软件开发 人员交互 软件可以工作 与客户合作 响应变更 软件设计 （设计活动）– 一般过程 体系结构设计 界面设计 用例设计 模块设计 数据模型设计 UML（以统一的、可规化的、多规点的方法对面吐对象软件系统进行行需求和设计建模）构成 建模机制 结构建模（静态建模）定义主要用来描述系统中包含的元素以及元素之间的关系 包含的图1.类图类描述具有相同特征、约束和语义的一类对象，这些对象具有共同的属性和操作。 ==类之间的关系：== 关联关系 表示两个类之间存在一种逻辑联系。 单向关联、双向关联(无向关联) 依赖关系 表明一个类使用或需要知道另一个类中包含的服务或信息。 整体-部分关系 聚集关系 部件类可以是多个整体类的组成部分。 构成关系 一个部件类只能位于一个整体类对象中 继承或泛化关系：一方是父类，另一方是子类 实现关系：一个类实现一个抽象类 关联类：用来记录与关联有关的信息，提供与关联有关的操作。 2.包图包用来对一组元素进行划分，是对复杂模型的一种分而治之的层次划分（包图是可看出成类图的一部分） 包之间的关系： 依赖关系 导入关系 合并关系 一个包中包含的内容合并到另一个包中，合并后的包拥有两个包的内容。 3.对象图对象是类的实例，对象之间的连接是类之间关联关系的实例 4.构件图描述系统中存在的构件、构件具有的接口、以及各个构件怎样通过接口连接起来形成一个完整的系统 根本特征：封装性和可复用性，通过接口向外部提供服务或请求外部服务 组成 构件 接口 装配连接子 把一个构件的服务和另一构件的需求连接起来 委托连接子 把复杂构件的外部接口与内部子构件的接口映射起来，由端口和委托连接子描述 5.组合机构图组合结构图通过内部结构、端口、协作等概念来描述复杂系统在运行时，系统、对象、协作实例等元素之间的结构关系。 6.部署图用来描述软件开发过程中生成的物理文件形式的软件或信息、运行平台中的物理节点和通信，以及软件文件到相应硬件节点的部署或映射。 行为建模（动态建模）定义 主要用来刻画系统中的动态行为、过程和步骤。 UML行为建模中提供的规图可以从不同侧面来描述软件系统的动态过程 结构建模对系统中的元素及其关系进行描述，而行为建模对这些元素完成特定任务的过程进行描述，两者相互结合就能够完整地描述整个系统的特征 包含的图1.活动图描述一个系统行为的执行过程或步骤（描述面向活动的动态行为） 活动和动作 活动是包含一组动作的行为，动作是活动中的一个步骤 对象节点 为了增强对活动的表达能力，活动图还有一些特殊的节点，以表示活动的输入、输出，以及动作之间传递的复杂对象 控制节点 在实际的活动流程中，会经常出现分支选择情况。还有可能执行完一个动作后，下面需要同时开始执行几个流程或几个流程完成后汇总为一个流程 泳道 明确活动中各个参与者的相应职责 2.顺序图顺序图用来描述对象之间动态的交互关系，主要强调完成某个场景的对象之间存在哪些消息传递以及消息的时间序。 3.通信图描述面向消息的动态行为 关注参与交互的对象通过连接组成的结构 4.交互概览图交互概览图通过类似于活动图的方式，描述交互之间的流程，给出交互控制流的概览。 5.时序图用来表示交互中关于消息时间的描述，并描述对象在生命线中，其所处状态或条件随着消息发生的变化 6.状态图描述一个实体在事件激励下的反应式动态行为，它包含实体的可能状态、每个状态下可以响应的事件发生时的状态变迁与动作。 状态：指所描述的元素在其生命周期中可位于的一种相对稳定的位置，一般会（隐含）满足一组条件。 迁移：从一个状态变化为另一个状态的过程 7.用例图用例图通常被用来描述系统的功能需求，从用户的角度对系统的功能规点进行建模。从系统的外部看系统功能，并不描述系统内部对功能的具体体现。 用例与参与者 用例之间的关系： 包含关系 扩展关系 4+1模型1.Kruchten 1.逻辑视图 系统的功能抽象。将系统分解为多个功能组件，描述其功能关系。 通常包括类图、对象图、状态图和通信图 ==用户关注== 2.开发视图 系统的详细设计和实现的抽象。描述系统的各部分如何被组织为模块和组件 通常包含类图、时序图、流程图 ==关注：程序员、软件管理人员== 3.过程规图 描述系统的非功能性需求和系统的运行特征。描述系统中的进程。 通常包含活动图 ==关注：集成工程师== 4.物理视图 描述系统的硬件拓扑结构以及软件组件在硬件上的部署。 通常包含部署图 ==关注：系统工程师== 5.场景视图 描述系统重要的业务用例。 2.Rational 1.设计视图 包含构建系统的类、接口和类之间的协作。 主要支持系统的功能性需求，即系统提供给用户的服务。 UML 静态方面由类图、对象图描述 动态方面由交互图、状态图和活动图描述。 2.交互视图 描述系统不同部分之间的控制流，包括可能的并发和同步机制。 主要解决系统的性能、可拓展性、吞吐量等问题 UML 静态方面由类图、对象图描述 动态方面由交互图、状态图和活动图描述。 3.实现视图 包含用于组装和发布物理系统的组件。 主要解决系统发布的配置管理问题。 UML 静态方面用构件图描述 动态方面用交互图、状态图和活动图描述 4.部署视图 包含形成系统硬件拓扑结构的节点。 主要解决构成物理系统的部件的分布、发布和安装问题。 UML 静态方面由部署图描述。 动态方面由交互图、状态图和活动图描述。 5.用例视图 包含描述用户、分析师和测试工程师看到的系统行为的用例。 UML 静态方面由用例图描述 动态方面由交互图、状态图和活动图描述。","categories":[],"tags":[]},{"title":"注解与反射","slug":"反射与注解","date":"2019-09-07T01:25:00.000Z","updated":"2020-06-30T16:41:39.162Z","comments":true,"path":"2019/09/07/fan-she-yu-zhu-jie/","link":"","permalink":"https://www.codeforce.top/2019/09/07/fan-she-yu-zhu-jie/","excerpt":"","text":"注解与反射 这一章节对理解框架十分重要，包括接下来的Spring、Mybatis 文章参考以下内容，转载或引用请注明原作者和引用文章 https://www.bilibili.com/video/BV1p4411P7V3 注解（Annotation）简介 注解是JDK 5.0开始引入技术（Annotation） 注解的作用 对程序作介绍（注释是对人来用的） 被其他程序使用 内置注解 @Override 在Java.lang.Override，声明重写超类后的第二个方法，作用范围：方法 @Deprecated 作用范围：方法，属性，类 表示不推荐使用此元素 @SuppressWarnings 用来抑制编译警告 与前俩个不同的是，此注解需要添加一个参数 @SuppressWarnings(“all”) @SuppressWarnings(“unchecked”) @SuppressWarnings(value ={“unchecked”,”deprecation”}) ….. 元注解 作用：负责注解其他注解，Java定义了四个标准类型 这些类型和它们所支持的类在Java.lang.Override包中可以找到 .( @Target , @Retention ,@Documented , @Inherited ) @Target：描述注解使用范围,所有范围如下 @Retention : 表示需要在什么级别保存该注释信息 , 用于描述注解的生命周期 (SOURCE &lt; CLASS &lt; RUNTIME) @Document：说明该注解将被包含在Javadoc中 @Inherited：说明子类可以继承父类中的该注解J 自定义注解 使用 @interface自定义注解时 , 自动继承了java.lang.annotation.Annotation接口 分析 @ interface用来声明一个注解 , 格式 : public @ interface 注解名 { 定义内容 } 若public不写默认为default 其中的每一个方法实际上是声明了一个配置参数. 方法的名称就是参数的名称. 返回值类型就是参数的类型 ( 返回值只能是基本类型,Class , String , enum ). 如果只有一个参数成员 , 一般参数名为value，通常这个参数名不需要在使用注解时表明 注解元素必须要有值 , 我们定义注解元素时 , 经常使用空字符串,0作为默认值 . 当默认值为-1时表示不存在 import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; public class Test3 { @MyAnnotation1(name = \"CodeForce\") public void test(){ } } @Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation1{ String name() default \"\"; int id() default -1 ;//-1代表不存在 等同于字符串的indexof()返回-1 String value() default \"\"; } 反射读取注解利用反射读取注解信息三步骤： 定义注解 在类中使用注解 使用反射获取注解，一般此步骤都由框架集成，以下手动实现 import java.lang.annotation.*; import java.lang.reflect.Field; public class test5 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { //通过反射获取类全部信息，所有东西 Class c1 = Class.forName(\"Person\"); //得到这个类的注解 Annotation[] annotations = c1.getAnnotations(); for (Annotation annotation : annotations) { System.out.println(annotation); } //获得类的注解value值 OnTable annotation = (OnTable) c1.getAnnotation(OnTable.class); System.out.println(annotation.value()); //获得类指定注解的值 Field name = c1.getDeclaredField(\"name\"); OnFiled onFiled = name.getAnnotation(OnFiled.class); System.out.println(onFiled.columnName()+\"---\"+onFiled.type()+\"---\"+onFiled.length()); //此方法就是通过得到信息,在JDBC生成相关SQL语句 } } @OnTable(\"db_person\") class Person{ @OnFiled(columnName = \"db_name\",type = \"varchar\",length = 3) private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + '}'; } } @Target(value = {ElementType.FIELD}) @Retention(value = RetentionPolicy.RUNTIME) @interface OnFiled{ String columnName(); //列名 String type(); //类型 int length();//长度 } @Target(value = {ElementType.TYPE}) @Retention(value = RetentionPolicy.RUNTIME) @interface OnTable{ String value();//只有一个推荐使用value } 反射（Reflection）动态语言与静态语言： Java虽然作为静态语言，但是利用反射机制使得Java拥有部分动态语言的特性 反射Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 Class c = Class.forName(\"java.util.List\"); 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射 {% asset_img image-20200630220318565.png %} Java反射提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解(框架注解开发的原理) 生成动态代理 ……. Java反射优点和缺点优点：可以实现动态创建对象和编译，体现出很大的灵活性 ! 缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。 反射相关的主要API java.lang.Class : 代表一个类 java.lang.reflect.Method : 代表类的方法 java.lang.reflect.Field : 代表类的成员变量 java.lang.reflect.Constructor : 代表类的构造器 …… Class类如果还得的话，Object作为所有类的基类有个getClass()方法 public final native Class&lt;?> getClass(); 以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。 对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。 Class 本身也是一个类 Class 对象只能由系统建立对象 一个加载的类在 JVM 中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个 Class 实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象 获取class几种方式 还有一种利用类加载器在下文中会提到 方法名 功能说明 static ClassforName(String name) 返回指定类名name的Class对象 Object newInstance() 调用缺省构造函数，返回Class对象的一个实例 getName() 返回此Class对象所表示的实体（类，接口，数组类或void）的名称。 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class[] getinterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组Method getMothed( Method getMothed(Stringname,Class.. T) 返回一个Method对象，此对象的形参类型为paramType Field[] getDeclaredFields() 返回Field对象的一个数组 哪些类型可以有class对象 class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。 interface：接口 []：数组 enum：枚举 annotation：注解@interface primitive type：基本数据类型 void 这里要注意一点的是数组只要元素类型与维度一样，就是同一个class Java内存分析 类的加载过程 类的加载与ClassLoader的理解 加载 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象. 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。 验证：确保加载的类信息符合JVM规范，没有安全方面的问题 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 初始化： 执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。 什么时候会发生类初始化？ 类的主动引用（一定会发生类的初始化） main在虚拟机启动时的初始化 new 一个类的对象 调用类的静态成员（除了final常量）和静态方法 对类进行反射调用 当初始化一个类，如果父类没有被初始化，则会先初始化它的父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 类名[] 名称 = new 类名[数量];//不会初始化此类 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 类加载器的作用 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象 {% asset_img image-20200630231710334.png %} 类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器 {% asset_img image-20200630231743009.png %} 创建运行时类的对象通过反射获取运行时类的完整结构Field、Method、Constructor、Superclass、Interface、Annotation 实现的全部接口 所继承的父类 全部的构造器 全部的方法 全部的Field 注解 …… 有了Class对象，能做什么事情 创建类的对象：调用Class对象的newInstance()方法 类必须有一个无参数的构造器。 类的构造器的访问权限需要足够 若没有无参构造器，则按照以下方式创建 通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。 通过Constructor实例化对象 //c1是类getclass得来的 //无参构造 Person person = (Person)c1.newInstance(); //有参构造 Constructor constructor = c1.getDeclaredConstructor(String.class); Person person1 = (Person) constructor.newInstance(\"CodeForce\"); System.out.println(person1); 调用指定方法 通过反射，调用类中的方法，通过Method类完成。 通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。 之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。 //通过反射获取一个方法(反射操作方法) Method setName = c1.getDeclaredMethod(\"setName\", String.class); setName.invoke(person,\"Code\"); System.out.println(person.getName()); Object 对应原方法的返回值，若原方法无返回值，此时返回null 若原方法若为静态方法，此时形参Object obj可为null 若原方法形参列表为空，则Object[] args为null 若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。 Field name = c1.getDeclaredField(\"name\"); //name作为private属性，正常不能直接访问，可通过setAccessible关闭检测 name.setAccessible(true); name.set(person,\"code1\"); System.out.println(person.getName()); setAccessible Method和Field、Constructor对象都有setAccessible()方法。 setAccessible作用是启动和禁用访问安全检查的开关。 参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。 使得原本无法访问的私有成员也可以访问 参数值为false则指示反射的对象应该实施Java语言访问检查 反射操作泛型 Java采用泛型擦除的机制来引入泛型 , Java中的泛型仅仅是给编译器javac使用的,确保数据的安全性和免去强制类型转换问题 , 但是 , 一旦编译完成 , 所有和泛型有关的类型全部擦除 为了通过反射操作这些类型 , Java新增了 ParameterizedType , GenericArrayType , TypeVariable和 WildcardType 几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型. ParameterizedType : 表示一种参数化类型,比如Collection GenericArrayType : 表示一种元素类型是参数化类型或者类型变量的数组类型 TypeVariable : 是各种类型变量的公共父接口 WildcardType : 代表一种通配符类型表达式 反射操作注解详情请看反射读取注解那段","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://www.codeforce.top/categories/Java-SE/"}],"tags":[{"name":"Java SE","slug":"Java-SE","permalink":"https://www.codeforce.top/tags/Java-SE/"},{"name":"框架","slug":"框架","permalink":"https://www.codeforce.top/tags/%E6%A1%86%E6%9E%B6/"}]}],"categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://www.codeforce.top/categories/Java-SE/"}],"tags":[{"name":"Java SE","slug":"Java-SE","permalink":"https://www.codeforce.top/tags/Java-SE/"},{"name":"框架","slug":"框架","permalink":"https://www.codeforce.top/tags/%E6%A1%86%E6%9E%B6/"}]}