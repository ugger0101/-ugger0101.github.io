{"meta":{"title":"codeforce","subtitle":"codeforce","description":"","author":"CXQ","url":"https://www.codeforce.top","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2020-06-28T13:54:20.303Z","comments":true,"path":"404.html","permalink":"https://www.codeforce.top/404.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2020-06-28T13:51:03.087Z","comments":true,"path":"categories/index.html","permalink":"https://www.codeforce.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-06-28T13:50:47.825Z","comments":true,"path":"tags/index.html","permalink":"https://www.codeforce.top/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-06-28T13:52:01.479Z","comments":true,"path":"about/index.html","permalink":"https://www.codeforce.top/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2020-06-28T13:52:22.115Z","comments":true,"path":"friends/index.html","permalink":"https://www.codeforce.top/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"软件体系结构（1）","slug":"软件体系结构（1）","date":"2020-12-28T06:32:04.000Z","updated":"2020-12-28T06:32:32.155Z","comments":true,"path":"2020/12/28/ruan-jian-ti-xi-jie-gou-1/","link":"","permalink":"https://www.codeforce.top/2020/12/28/ruan-jian-ti-xi-jie-gou-1/","excerpt":"","text":"软件体系结构软件的定义计算机软件 = 程序 + 数据 +文档 软件体系结构的定义软件体系结构=组件+连接件+约束 组件：具有某种功能的可重用的软件模块单元，表示系统中主要的计算单元和数据存储 连接件：表示组件之间的交互，简单的连接件有：管道、过程调用 、事件广播等 约束：表示组件和连接件的拓扑逻辑和约束。 软件体系结构的内容 体系结构是软件系统的抽象描述，是需求到实现的桥梁。 体系结构的设计方法： 通过一系列设计活动获得满足系统功能性和非功能性需要的模型 体系结构的分析方法 基于形式化方法、数学模型和模拟技术得出量化分析结果 基于调查问卷、场景分析、检查表等手段侧重可维护性、可复用性等难以量化的质量属性 体系结构的复用 代码复用 设计复用 过程复用 软件工程三要素 软件生存周期 设计活动 软件开发模型 瀑布模型 带反馈的瀑布模型 V模型 快速原型模型 迭代模型 并行模型 螺旋模型 螺旋模型是瀑布模型和原型模型的有机结合 软件设计（设计活动） 体系结构设计 界面设计 用例设计 模块设计 数据模型设计 UML（以统一的、可规化的、多规点的方法对面吐对象软件系统进行行需求和设计建模）构成 建模机制 结构建模（静态建模）定义主要用来描述系统中包含的元素以及元素之间的关系 包含的图1.类图类描述具有相同特征、约束和语义的一类对象，这些对象具有共同的属性和操作。 ==类之间的关系：== 关联关系 表示两个类之间存在一种逻辑联系。 单向关联、双向关联(无向关联) 依赖关系 表明一个类使用或需要知道另一个类中包含的服务或信息。 整体-部分关系 聚集关系 部件类可以是多个整体类的组成部分。 构成关系 一个部件类只能位于一个整体类对象中 继承或泛化关系：一方是父类，另一方是子类 实现关系：一个类实现一个抽象类 关联类：用来记录与关联有关的信息，提供与关联有关的操作。 2.包图包用来对一组元素进行划分，是对复杂模型的一种分而治之的层次划分（包图是可看出成类图的一部分） 包之间的关系： 依赖关系 导入关系 合并关系 一个包中包含的内容合并到另一个包中，合并后的包拥有两个包的内容。 3.对象图对象是类的实例，对象之间的连接是类之间关联关系的实例 4.构件图描述系统中存在的构件、构件具有的接口、以及各个构件怎样通过接口连接起来形成一个完整的系统 根本特征：封装性和可复用性，通过接口向外部提供服务或请求外部服务 组成 构件 接口 装配连接子 把一个构件的服务和另一构件的需求连接起来 委托连接子 把复杂构件的外部接口与内部子构件的接口映射起来，由端口和委托连接子描述 5.组合机构图组合结构图通过内部结构、端口、协作等概念来描述复杂系统在运行时，系统、对象、协作实例等元素之间的结构关系。 6.部署图用来描述软件开发过程中生成的物理文件形式的软件或信息、运行平台中的物理节点和通信，以及软件文件到相应硬件节点的部署或映射。 行为建模（动态建模）定义 主要用来刻画系统中的动态行为、过程和步骤。 UML行为建模中提供的规图可以从不同侧面来描述软件系统的动态过程 结构建模对系统中的元素及其关系进行描述，而行为建模对这些元素完成特定任务的过程进行描述，两者相互结合就能够完整地描述整个系统的特征 包含的图1.活动图描述一个系统行为的执行过程或步骤（描述面向活动的动态行为） 活动和动作 活动是包含一组动作的行为，动作是活动中的一个步骤 对象节点 为了增强对活动的表达能力，活动图还有一些特殊的节点，以表示活动的输入、输出，以及动作之间传递的复杂对象 控制节点 在实际的活动流程中，会经常出现分支选择情况。还有可能执行完一个动作后，下面需要同时开始执行几个流程或几个流程完成后汇总为一个流程 泳道 明确活动中各个参与者的相应职责 2.顺序图顺序图用来描述对象之间动态的交互关系，主要强调完成某个场景的对象之间存在哪些消息传递以及消息的时间序。 3.通信图描述面向消息的动态行为 关注参与交互的对象通过连接组成的结构 4.交互概览图交互概览图通过类似于活动图的方式，描述交互之间的流程，给出交互控制流的概览。 5.时序图用来表示交互中关于消息时间的描述，并描述对象在生命线中，其所处状态或条件随着消息发生的变化 6.状态图描述一个实体在事件激励下的反应式动态行为，它包含实体的可能状态、每个状态下可以响应的事件发生时的状态变迁与动作。 状态：指所描述的元素在其生命周期中可位于的一种相对稳定的位置，一般会（隐含）满足一组条件。 迁移：从一个状态变化为另一个状态的过程 7.用例图用例图通常被用来描述系统的功能需求，从用户的角度对系统的功能规点进行建模。从系统的外部看系统功能，并不描述系统内部对功能的具体体现。 用例与参与者 用例之间的关系： 包含关系 扩展关系 4+1模型1.Kruchten 1.逻辑视图 系统的功能抽象。将系统分解为多个功能组件，描述其功能关系。 通常包括类图、对象图、状态图和通信图 ==用户关注== 2.开发视图 系统的详细设计和实现的抽象。描述系统的各部分如何被组织为模块和组件 通常包含类图、时序图、流程图 ==关注：程序员、软件管理人员== 3.过程规图 描述系统的非功能性需求和系统的运行特征。描述系统中的进程。 通常包含活动图 ==关注：集成工程师== 4.物理视图 描述系统的硬件拓扑结构以及软件组件在硬件上的部署。 通常包含部署图 ==关注：系统工程师== 5.场景视图 描述系统重要的业务用例。 2.Rational 1.设计视图 包含构建系统的类、接口和类之间的协作。 主要支持系统的功能性需求，即系统提供给用户的服务。 UML 静态方面由类图、对象图描述 动态方面由交互图、状态图和活动图描述。 2.交互视图 描述系统不同部分之间的控制流，包括可能的并发和同步机制。 主要解决系统的性能、可拓展性、吞吐量等问题 UML 静态方面由类图、对象图描述 动态方面由交互图、状态图和活动图描述。 3.实现视图 包含用于组装和发布物理系统的组件。 主要解决系统发布的配置管理问题。 UML 静态方面用构件图描述 动态方面用交互图、状态图和活动图描述 4.部署视图 包含形成系统硬件拓扑结构的节点。 主要解决构成物理系统的部件的分布、发布和安装问题。 UML 静态方面由部署图描述。 动态方面由交互图、状态图和活动图描述。 5.用例视图 包含描述用户、分析师和测试工程师看到的系统行为的用例。 UML 静态方面由用例图描述 动态方面由交互图、状态图和活动图描述。","categories":[],"tags":[]},{"title":"注解与反射","slug":"反射与注解","date":"2019-09-07T01:25:00.000Z","updated":"2020-06-30T16:41:39.162Z","comments":true,"path":"2019/09/07/fan-she-yu-zhu-jie/","link":"","permalink":"https://www.codeforce.top/2019/09/07/fan-she-yu-zhu-jie/","excerpt":"","text":"注解与反射 这一章节对理解框架十分重要，包括接下来的Spring、Mybatis 文章参考以下内容，转载或引用请注明原作者和引用文章 https://www.bilibili.com/video/BV1p4411P7V3 注解（Annotation）简介 注解是JDK 5.0开始引入技术（Annotation） 注解的作用 对程序作介绍（注释是对人来用的） 被其他程序使用 内置注解 @Override 在Java.lang.Override，声明重写超类后的第二个方法，作用范围：方法 @Deprecated 作用范围：方法，属性，类 表示不推荐使用此元素 @SuppressWarnings 用来抑制编译警告 与前俩个不同的是，此注解需要添加一个参数 @SuppressWarnings(“all”) @SuppressWarnings(“unchecked”) @SuppressWarnings(value ={“unchecked”,”deprecation”}) ….. 元注解 作用：负责注解其他注解，Java定义了四个标准类型 这些类型和它们所支持的类在Java.lang.Override包中可以找到 .( @Target , @Retention ,@Documented , @Inherited ) @Target：描述注解使用范围,所有范围如下 @Retention : 表示需要在什么级别保存该注释信息 , 用于描述注解的生命周期 (SOURCE &lt; CLASS &lt; RUNTIME) @Document：说明该注解将被包含在Javadoc中 @Inherited：说明子类可以继承父类中的该注解J 自定义注解 使用 @interface自定义注解时 , 自动继承了java.lang.annotation.Annotation接口 分析 @ interface用来声明一个注解 , 格式 : public @ interface 注解名 { 定义内容 } 若public不写默认为default 其中的每一个方法实际上是声明了一个配置参数. 方法的名称就是参数的名称. 返回值类型就是参数的类型 ( 返回值只能是基本类型,Class , String , enum ). 如果只有一个参数成员 , 一般参数名为value，通常这个参数名不需要在使用注解时表明 注解元素必须要有值 , 我们定义注解元素时 , 经常使用空字符串,0作为默认值 . 当默认值为-1时表示不存在 import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; public class Test3 { @MyAnnotation1(name = \"CodeForce\") public void test(){ } } @Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation1{ String name() default \"\"; int id() default -1 ;//-1代表不存在 等同于字符串的indexof()返回-1 String value() default \"\"; } 反射读取注解利用反射读取注解信息三步骤： 定义注解 在类中使用注解 使用反射获取注解，一般此步骤都由框架集成，以下手动实现 import java.lang.annotation.*; import java.lang.reflect.Field; public class test5 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { //通过反射获取类全部信息，所有东西 Class c1 = Class.forName(\"Person\"); //得到这个类的注解 Annotation[] annotations = c1.getAnnotations(); for (Annotation annotation : annotations) { System.out.println(annotation); } //获得类的注解value值 OnTable annotation = (OnTable) c1.getAnnotation(OnTable.class); System.out.println(annotation.value()); //获得类指定注解的值 Field name = c1.getDeclaredField(\"name\"); OnFiled onFiled = name.getAnnotation(OnFiled.class); System.out.println(onFiled.columnName()+\"---\"+onFiled.type()+\"---\"+onFiled.length()); //此方法就是通过得到信息,在JDBC生成相关SQL语句 } } @OnTable(\"db_person\") class Person{ @OnFiled(columnName = \"db_name\",type = \"varchar\",length = 3) private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + '}'; } } @Target(value = {ElementType.FIELD}) @Retention(value = RetentionPolicy.RUNTIME) @interface OnFiled{ String columnName(); //列名 String type(); //类型 int length();//长度 } @Target(value = {ElementType.TYPE}) @Retention(value = RetentionPolicy.RUNTIME) @interface OnTable{ String value();//只有一个推荐使用value } 反射（Reflection）动态语言与静态语言： Java虽然作为静态语言，但是利用反射机制使得Java拥有部分动态语言的特性 反射Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 Class c = Class.forName(\"java.util.List\"); 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射 {% asset_img image-20200630220318565.png %} Java反射提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解(框架注解开发的原理) 生成动态代理 ……. Java反射优点和缺点优点：可以实现动态创建对象和编译，体现出很大的灵活性 ! 缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。 反射相关的主要API java.lang.Class : 代表一个类 java.lang.reflect.Method : 代表类的方法 java.lang.reflect.Field : 代表类的成员变量 java.lang.reflect.Constructor : 代表类的构造器 …… Class类如果还得的话，Object作为所有类的基类有个getClass()方法 public final native Class&lt;?> getClass(); 以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。 对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。 Class 本身也是一个类 Class 对象只能由系统建立对象 一个加载的类在 JVM 中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个 Class 实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象 获取class几种方式 还有一种利用类加载器在下文中会提到 方法名 功能说明 static ClassforName(String name) 返回指定类名name的Class对象 Object newInstance() 调用缺省构造函数，返回Class对象的一个实例 getName() 返回此Class对象所表示的实体（类，接口，数组类或void）的名称。 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class[] getinterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组Method getMothed( Method getMothed(Stringname,Class.. T) 返回一个Method对象，此对象的形参类型为paramType Field[] getDeclaredFields() 返回Field对象的一个数组 哪些类型可以有class对象 class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。 interface：接口 []：数组 enum：枚举 annotation：注解@interface primitive type：基本数据类型 void 这里要注意一点的是数组只要元素类型与维度一样，就是同一个class Java内存分析 类的加载过程 类的加载与ClassLoader的理解 加载 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象. 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。 验证：确保加载的类信息符合JVM规范，没有安全方面的问题 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 初始化： 执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。 什么时候会发生类初始化？ 类的主动引用（一定会发生类的初始化） main在虚拟机启动时的初始化 new 一个类的对象 调用类的静态成员（除了final常量）和静态方法 对类进行反射调用 当初始化一个类，如果父类没有被初始化，则会先初始化它的父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 类名[] 名称 = new 类名[数量];//不会初始化此类 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 类加载器的作用 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象 {% asset_img image-20200630231710334.png %} 类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器 {% asset_img image-20200630231743009.png %} 创建运行时类的对象通过反射获取运行时类的完整结构Field、Method、Constructor、Superclass、Interface、Annotation 实现的全部接口 所继承的父类 全部的构造器 全部的方法 全部的Field 注解 …… 有了Class对象，能做什么事情 创建类的对象：调用Class对象的newInstance()方法 类必须有一个无参数的构造器。 类的构造器的访问权限需要足够 若没有无参构造器，则按照以下方式创建 通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。 通过Constructor实例化对象 //c1是类getclass得来的 //无参构造 Person person = (Person)c1.newInstance(); //有参构造 Constructor constructor = c1.getDeclaredConstructor(String.class); Person person1 = (Person) constructor.newInstance(\"CodeForce\"); System.out.println(person1); 调用指定方法 通过反射，调用类中的方法，通过Method类完成。 通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。 之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。 //通过反射获取一个方法(反射操作方法) Method setName = c1.getDeclaredMethod(\"setName\", String.class); setName.invoke(person,\"Code\"); System.out.println(person.getName()); Object 对应原方法的返回值，若原方法无返回值，此时返回null 若原方法若为静态方法，此时形参Object obj可为null 若原方法形参列表为空，则Object[] args为null 若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。 Field name = c1.getDeclaredField(\"name\"); //name作为private属性，正常不能直接访问，可通过setAccessible关闭检测 name.setAccessible(true); name.set(person,\"code1\"); System.out.println(person.getName()); setAccessible Method和Field、Constructor对象都有setAccessible()方法。 setAccessible作用是启动和禁用访问安全检查的开关。 参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。 使得原本无法访问的私有成员也可以访问 参数值为false则指示反射的对象应该实施Java语言访问检查 反射操作泛型 Java采用泛型擦除的机制来引入泛型 , Java中的泛型仅仅是给编译器javac使用的,确保数据的安全性和免去强制类型转换问题 , 但是 , 一旦编译完成 , 所有和泛型有关的类型全部擦除 为了通过反射操作这些类型 , Java新增了 ParameterizedType , GenericArrayType , TypeVariable和 WildcardType 几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型. ParameterizedType : 表示一种参数化类型,比如Collection GenericArrayType : 表示一种元素类型是参数化类型或者类型变量的数组类型 TypeVariable : 是各种类型变量的公共父接口 WildcardType : 代表一种通配符类型表达式 反射操作注解详情请看反射读取注解那段","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://www.codeforce.top/categories/Java-SE/"}],"tags":[{"name":"Java SE","slug":"Java-SE","permalink":"https://www.codeforce.top/tags/Java-SE/"},{"name":"框架","slug":"框架","permalink":"https://www.codeforce.top/tags/%E6%A1%86%E6%9E%B6/"}]}],"categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://www.codeforce.top/categories/Java-SE/"}],"tags":[{"name":"Java SE","slug":"Java-SE","permalink":"https://www.codeforce.top/tags/Java-SE/"},{"name":"框架","slug":"框架","permalink":"https://www.codeforce.top/tags/%E6%A1%86%E6%9E%B6/"}]}