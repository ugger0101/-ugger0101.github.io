<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机英语</title>
      <link href="2021/01/05/ji-suan-ji-ying-yu/"/>
      <url>2021/01/05/ji-suan-ji-ying-yu/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机英语"><a href="#计算机英语" class="headerlink" title="计算机英语"></a>计算机英语</h1><h2 id="Unit-1"><a href="#Unit-1" class="headerlink" title="Unit 1"></a>Unit 1</h2><h3 id="短语翻译"><a href="#短语翻译" class="headerlink" title="短语翻译"></a>短语翻译</h3><ol><li><p>artificial intelligence 人工智能</p></li><li><p>paper-tape reader 纸带阅读器</p></li><li><p>optical computer 光计算机</p></li><li><p>neural network 神经网络</p></li><li><p>instruction set 指令集</p></li><li><p>parallel processing 并行处理</p></li><li><p>difference engine 差分机</p></li><li><p>versatile logical element 通用逻辑元件</p></li><li><p>silicon substrate 硅衬底</p></li><li><p>vacuum tube 真空管</p></li><li><p>数据的存储与处理 the storage and handling of data</p></li><li><p>超大规模集成电路 very large-scale integrated circuit</p></li><li><p>中央处理器 central processing unit</p></li><li><p>个人计算机 personal computer</p></li><li><p>模拟计算机 analogue computer</p></li><li><p>数字计算机 digital computer</p></li><li><p>通用计算机 general-purpose computer</p></li><li><p>处理器芯片 processor chip</p></li><li><p>操作指令 operating instructions</p></li><li><p>输入设备 input device</p></li></ol><h3 id="完型填空"><a href="#完型填空" class="headerlink" title="完型填空"></a>完型填空</h3><p>​            We can define a computer as a device that accepts input, processes data, stores data, and produces output. According to the <strong><u>mode</u></strong> of processing, computers are either analog or <strong><u>digital</u></strong>. They can also be classified as mainframes, <strong><u>minicomputers</u></strong>, workstations, or microcomputers. All else (for example, the age of the machine) being equal, this <strong><u>categorization</u></strong> provides some indication of the computer’s <strong><u>speed</u></strong>, size, cost, and abilities.</p><p>​            Ever since the <strong><u>advent</u></strong> of computers, there have been constant changes. First-generation computers of historic <strong><u>significance</u></strong>, such as UNIVAC (通用自动计算机), introduced in the early 1950s, were <strong><u>based</u></strong> on vacuum tubes. Second-generation computers, <strong><u>appearing</u></strong> in the early 1960s, were those in which <strong><u>transistors</u></strong> replaced vacuum tubes. In third-generation computers, dating from the 1960s, integrated <strong><u>circuits</u></strong> replaced transistors. In fourth-generation computers such as <strong><u>microcomputers</u></strong>, which first appeared in the mid-1970s, large-scale <strong><u>integration</u></strong> enabled thousands of circuits to be incorporated on one <strong><u>chip</u></strong>. Fifth-generation computers are expected to <strong><u>combine</u></strong> very-large-scale integration with sophisticated approaches to <strong><u>computing</u></strong>, including artificial intelligence and true distributed processing.</p><p>​            我们可以将计算机定义为接受输入、处理数据、存储数据和产生输出的设备。根据处理方式，计算机可以是模拟的，也可以是数字的。它们也可以分为大型机、小型计算机、工作站或微型计算机。除此之外（例如，机器的年龄）相同，这种分类提供了计算机速度、大小、成本和能力的一些指示.自从计算机出现以来，一直在不断地变化。具有历史意义的第一代计算机，如20世纪50年代初推出的UNIVAC，都是以真空管为基础的。20世纪60年代初出现的第二代计算机是晶体管取代真空管的计算机。在20世纪60年代的第三代计算机中，集成电路取代了晶体管。在20世纪70年代中期首次出现的第四代计算机（如微型计算机）中，大规模集成使得成千上万的电路集成在一个芯片上。预计第五代计算机将结合非常大规模的集成和复杂的计算方法，包括人工智能和真正的分布式处理。</p><h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><p>   计算机将变得更加先进，也将变得更加容易使用。语音识别的改进将使计算机的操作更加容易。虚拟现实，即使用所有人类官能与计算机进行交互的技术，也将有助于创建更好的人机接口。人们正在开发其他的奇异计算模型，包括使用生物机体的生物计算、使用具有特定属性的分子计算，以及使用遗传基本单位DNA（脱氧核糖核酸）存储数据和执行运算的计算。这些都是可能的未来计算平台的例子，而它们迄今还能力有限或完全属于理论范畴。科学家们研究它们，是因为嵌入硅中的电路的微小型化受到物理限制。还有一些限制与即使最微小的晶体管也会产生的热量有关。</p><p><strong>[课文部分翻译]</strong></p><p>（1）<strong>Different types and sizes of computers find uses throughout society in the storage and handling of data, from secret government files to banking transactions to private household accounts. Computers have opened up a new era in manufacturing through the techniques of automation, and they have enhanced modern communication systems.</strong> </p><p>不同类型和大小的计算机在整个社会被用于存储和处理各种数据，从保密政府文件、银行交易到私人家庭账目。计算机通过自动化技术开辟了制造业的新纪元，而且它们也增强了现代通信系统的性能。</p><p>​    </p><p>（2）<strong>They are essential tools in almost every field of research and applied technology, from constructing models of the universe to producin tomorrow’s weather reports, and their use has in itself opened up new areas of conjecture.</strong></p><p>在几乎每一个研究和应用技术领域，从构建宇宙模型到产生明天的气象报告，计算机都是必要的工具，并且它们的应用本身就开辟了人们推测的新领域。</p><p>(3)<strong>The“fifth-generation” computer effort to develop computers that can solve complex problems in ways that might eventually merit the description “creative” is another trend in computer development, the ideal goal being true artificial intelligence.</strong></p><p><strong>Another trend in computer development is The“fifth-generation” computer effort to develop computers that can solve complex problems in ways that might eventually merit the description “creative” , the ideal goal being true artificial intelligence.</strong></p><p>计算机发展的另一个趋势是“第五代”计算机的研制工作，亦即研制可以解决复杂问题而且其解决方法用“创造性的”这个词来形容或许最终名副其实的计算机，理想的目标是真正的人工智能。</p><p>(4)<strong>Another ongoing trend is the increase in computer networking, which now employs the worldwide data communications system of satellite and cable links to connect computer globally.</strong></p><p>另一个持续不断的趋势是计算机联网的增加。计算机联网现在使用由卫星和电缆链路构成的世界范围的数据通信系统，来将全球的计算机连在一起。</p><h2 id="Unit-2"><a href="#Unit-2" class="headerlink" title="Unit 2"></a>Unit 2</h2><h3 id="短语翻译-1"><a href="#短语翻译-1" class="headerlink" title="短语翻译"></a>短语翻译</h3><ol><li><p>function key                     功能键，操作键，函数键</p></li><li><p>voice recognition module          语音识别模块</p></li><li><p>touch-sensitive region              触敏区</p></li><li><p>address bus                      地址总线</p></li><li><p>flatbed scanner                   平板扫描仪</p></li><li><p>dot-matrix printer                 点阵打印机</p></li><li><p>parallel connection                并行连接</p></li><li><p>cathode ray tube                  阴极射线管</p></li><li><p>video game                      电子游戏</p></li><li><p>audio signal                      音频信号</p></li><li><p>operating system                  操作系统</p></li><li><p>LCD (liquid crystal display)         液晶显示(器)</p></li><li><p>inkjet printer                     喷墨打印机</p></li><li><p>data bus                         数据总线</p></li><li><p>serial connection                  串行连接</p></li><li><p>volatile memory                  易失性存储器</p></li><li><p>laser printer                      激光打印机</p></li><li><p>disk drive                       磁盘驱动器</p></li><li><p>BIOS (Basic Input/Output System)  基本输入/输出系统</p></li><li><p>video display                    视频显示器</p></li></ol><h3 id="完型填空-1"><a href="#完型填空-1" class="headerlink" title="完型填空"></a>完型填空</h3><p>CD-ROM stands for compact disc read-only memory. Unlike <strong><u>floppy</u></strong> and hard disks, which use magnetic charges to represent 1s and 0s, <strong><u>optical</u></strong> discs use reflected light. On a CD-ROM disc, 1s and 0s are represented by <strong><u>flat</u></strong> areas and bumpy(高低不平的) areas (called “pits”) on its bottom <strong><u>surface</u></strong>. The CD-ROM disc is read by a <strong><u>laser</u></strong> that projects a tiny beam of <strong><u>light</u></strong> on these areas. The amount of <strong><u>reflected</u></strong> light determines whether the area <strong><u>represents</u></strong> a 1 or a 0.</p><p>Like a <strong><u>commercial</u></strong> CD found in music stores, a CD-ROM is a “read-only” <strong><u>disc</u></strong>. Read-only means it cannot be written on or <strong><u>erased</u></strong> by the user. Thus, you as a user have <strong><u>access</u></strong> only to the data imprinted (压印) by the publisher.</p><p>A single CD-ROM disc can <strong><u>store</u></strong> 650 megabytes (兆字节) of data. That is <strong><u>equivalent</u></strong> to 451 floppy disks. With that much <strong><u>information</u></strong> on a single disc, the time to <strong><u>retrieve</u></strong> or access the information is very important. An important characteristic of CD-ROM drives is their access rate.</p><h3 id="翻译-1"><a href="#翻译-1" class="headerlink" title="翻译"></a>翻译</h3><p>调制解调器是在模拟与数字信号之间进行转换的设备。</p><p>计算机使用的是数字信号，这种信号由离散单元组成，通常用一系列1和0表示。</p><p>模拟信号是连续变化的；声波就是模拟信号的一个例子。</p><p>调制解调器经常用于实现计算机之间通过电话线的互相通信。</p><p>调制解调器将发送端计算机的数字信号转换成可通过电话线传输的模拟信号。</p><p>信号到达目的地后，另外一个调制解调器重构原来的数字信号，供接收端计算机处理。</p><p>如果两个调制解调器可同时互相发送数据，那么它们采用的就是全双工工作方式；如果一次只有一个调制解调器可以发送数据，那么它们采用的则是半双工工作方式。</p><h2 id="Unit-3"><a href="#Unit-3" class="headerlink" title="Unit 3"></a>Unit 3</h2><h3 id="短语翻译-2"><a href="#短语翻译-2" class="headerlink" title="短语翻译"></a>短语翻译</h3><ol><li><p>storage register 存储寄存器</p></li><li><p>function statement 函数语句</p></li><li><p>program statement 程序语句</p></li><li><p>object-oriented language 面向对象语言</p></li><li><p>assembly language  汇编语言</p></li><li><p>intermediate language 中间语言，中级语言</p></li><li><p>relational language  关系（型）语言</p></li><li><p>artificial language  人工语言</p></li><li><p>data declaration  数据声明</p></li><li><p>Structured Query Language  结构化查询语言</p></li><li><p>可执行程序 executable program</p></li><li><p>程序模块 program module</p></li><li><p>条件语句 conditional statement</p></li><li><p>赋值语句 assignment statement</p></li><li><p>逻辑语言 logic language</p></li><li><p>机器语言 machine language</p></li><li><p>函数式语言 functional language</p></li><li><p>程序设计语言 programming language</p></li><li><p>运行计算机程序 run a computer program</p></li><li><p>计算机程序员 computer programmer</p></li></ol><h3 id="完形填空"><a href="#完形填空" class="headerlink" title="完形填空"></a>完形填空</h3><p>A programming language is a language used to write instructions for the computer. It lets the programmer express data <strong><u>processing</u></strong> in a symbolic manner without regard to machine-specific details.</p><p>The difficulty of writing programs in the <strong><u>machine</u></strong> language of 0s and 1s led first to the development of assembly language, which allows <strong><u>programmers</u></strong> to use mnemonics (助记符) for instructions and symbols for variables. Such programs are then <strong><u>translated</u></strong> by a program known as an assembler (汇编程序，汇编器) into the binary encoding used by the <strong><u>computer</u></strong>. Other pieces of system software known as linking loaders(连接装入程序) <strong><u>combine</u></strong> pieces of assembled code and load them into the machine’s main <strong><u>memory</u></strong> unit, where they are then ready for execution. The concept of linking <strong><u>separate</u></strong> pieces of code was important, since it allowed “libraries” of <strong><u>programs</u></strong> to be built up to carry out common tasks—a first <strong><u>step</u></strong> toward the increasingly emphasized notion of software <strong><u>reuse</u></strong>. Assembly language was found to be sufficiently <strong><u>inconvenient</u></strong> that higher-level languages (closer to natural languages) were invented in the 1950s for easier, faster <strong><u>programming</u></strong>; along with them came the need for compilers, programs that translate <strong><u>high-level</u></strong> language programs into machine code. As programming languages became more <strong><u>powerful</u></strong> and abstract, building efficient compilers that create high-quality code in terms of <strong><u>execution</u></strong> speed and storage consumption became an interesting computer science problem in itself.</p><p>编程语言是一种用来为计算机编写指令的语言。它允许程序员以符号方式表示数据处理，而不考虑机器的特定细节。用0和1的机器语言编写程序的困难首先导致了汇编语言的发展，它允许程序员使用助记符（mnemonics）作为指令和变量符号。然后，这种程序被称为汇编程序（汇编器）的程序翻译成计算机使用的二进制编码。其他系统软件被称为链接加载程序（linking loaders，linking loaders）将组装好的代码组合在一起，加载到机器的主内存单元中，然后在那里它们就可以执行了。连接不同代码片段的概念很重要，因为它允许程序的“库”被构建来执行共同的任务，这是朝着日益强调的软件重用概念迈出的第一步。汇编语言被认为是非常不方便的，更高级的语言（更接近自然语言）在20世纪50年代被发明出来，以便更容易、更快地进行编程；随之而来的是对编译器的需求，即将高级语言程序翻译成机器码的程序。随着编程语言变得越来越强大和抽象，构建高效的编译器来创建执行速度和存储消耗方面的高质量代码本身就成为一个有趣的计算机科学问题。</p><h3 id="翻译-2"><a href="#翻译-2" class="headerlink" title="翻译"></a>翻译</h3><p>面向对象程序设计语言，如C++和Java，基于传统的高级语言，但它们使程序设计员能够从合作对象集而非命令列表的角度进行思考。诸如圆之类的对象具有像圆的半径一类的属性，以及在计算机屏幕上绘制该对象的命令。一个对象类可以从其他的对象类继承特征。例如，定义正方形的类可以从定义长方形的类那里继承直角等特征。这一套程序设计类简化了程序设计员的工作，带来了更多“可复用的”计算机代码。可复用代码使程序设计员可以使用已经设计、编写和测试的代码。这使得程序设计员的工作变得比较容易，并带来更加可靠和高效的程序。 </p><h2 id="Unit-6"><a href="#Unit-6" class="headerlink" title="Unit 6"></a>Unit 6</h2><h3 id="短语翻译-3"><a href="#短语翻译-3" class="headerlink" title="短语翻译"></a>短语翻译</h3><ol><li><p>end user 最终用户，终端用户</p></li><li><p>atomic operation 原子操作</p></li><li><p>database administrator 数据库管理员</p></li><li><p>relational database model 关系数据库模型</p></li><li><p>local data 本地数据</p></li><li><p>object-oriented database 面向对象数据库</p></li><li><p>database management system (DBMS) 数据库管理系统</p></li><li><p>entity-relationship model (ERM) 实体关系模型</p></li><li><p>distributed database 分布式数据库</p></li><li><p>flat file 平面文件</p></li><li><p>二维表 two-dimensional table</p></li><li><p>数据属性 data attribute</p></li><li><p>数据库对象 database object</p></li><li><p>存储设备 storage device</p></li><li><p>数据类型 data type</p></li><li><p>数据插入与删除 data insertion and deletion</p></li><li><p>层次数据库模型 hierarchical database model</p></li><li><p>数据库体系结构 database architecture</p></li><li><p>关系数据库管理系统 relational database management system (RDBMS)</p></li><li><p>全局控制总线 global control bus</p></li></ol><h3 id="完型填空-2"><a href="#完型填空-2" class="headerlink" title="完型填空"></a>完型填空</h3><p>A database is any collection of data organized for storage in a computer memory and designed for easy <strong><u>access</u></strong> by authorized users. The data may be in the form of <strong><u>text</u></strong>, numbers, or encoded graphics. Small databases were first <strong><u>developed</u></strong> or funded by the U.S. government for agency or professional <strong><u>use</u></strong>. In the 1960s, some databases became commercially <strong><u>available</u></strong>, but their use was funnelled (传送) through a few so-called research <strong><u>centers</u></strong> that collected information inquiries and handled them in batches (批，批量). <strong><u>Online</u></strong> databases—that is, databases available to anyone who could <strong><u>link</u></strong> up to them by computer—first appeared in the 1970s. Since their first, <strong><u>experimental</u></strong> appearance in the 1950s, databases have become so <strong><u>important</u></strong> that they can be found in almost <strong><u>every</u></strong> field of information. Government, military, and industrial <strong><u>databases</u></strong> are often highly restricted, and professional databases are usually of <strong><u>limited</u></strong> interest. A wide range of commercial, governmental, and <strong><u>nonprofit</u></strong> databases are available to the general <strong><u>public</u></strong>, however, and may be used by anyone who owns or has access to the <strong><u>equipment</u></strong> that they require.</p><h3 id="翻译-3"><a href="#翻译-3" class="headerlink" title="翻译"></a>翻译</h3><p>在关系数据库中，表的行表示记录（关于不同项的信息集），列表示字段（一个记录的特定属性）。</p><p>在进行搜索时，关系数据库将一个表中的一个字段的信息与另一个表的一个相应字段的信息进行匹配，以生成将来自这两个表的所要求数据结合起来的另一个表。例如，如果一个表包含EMPLOYEE-ID、LAST-NAME、FIRST-NAME和HIRE-DATE字段，另一个表包含DEPT、EMPLOYEE-ID和SALARY字段，关系数据库可匹配这两个表中的EMPLOYEE-ID字段，以找到特定的信息，如所有挣到一定薪水的雇员的姓名或所有在某个日期之后受雇的雇员所属的部门。</p><p>换言之，关系数据库使用两个表中的匹配值，将一个表中的信息与另一个表中的信息联系起来。微型计算机数据库产品一般是关系数据库。</p><h2 id="Unit-9"><a href="#Unit-9" class="headerlink" title="Unit 9"></a>Unit 9</h2><ol><li><p>server farm 大型机服务器</p></li><li><p>access protocol 存取协议，访问协议</p></li><li><p>storage area network 存储区域网（络）</p></li><li><p>high-throughput computing 高吞吐（量）计算</p></li><li><p>server cluster 服务器集群</p></li><li><p>public cloud 公共云</p></li><li><p>grid computing 网格计算</p></li><li><p>security-aware cloud architecture 具有安全意识的云体系结构</p></li><li><p>social networking 社交网络</p></li><li><p>utility computing 效用计算</p></li><li><p>云计算提供商 cloud computing provider</p></li><li><p>存储芯片 memory chip</p></li><li><p>基于内部网的私有云 intranet-based private cloud</p></li><li><p>网络带宽 network bandwidth</p></li><li><p>混合云 hybrid cloud</p></li><li><p>磁盘阵列 disk array</p></li><li><p>软件即服务 Software as a Service (SaaS)</p></li><li><p>集群计算 cluster computing</p></li><li><p>虚拟化计算机资源 virtualized computer resources</p></li><li><p>多核处理器 multi-core processor</p></li></ol><h3 id="完型填空-3"><a href="#完型填空-3" class="headerlink" title="完型填空"></a>完型填空</h3><p>The architecture of a cloud is developed at three layers: infrastructure, platform, and application. The infrastructure <strong><u>layer</u></strong> is deployed first to support IaaS (Infrastructure as a Service) services. This layer serves as the <strong><u>foundation</u></strong> for building the platform layer of the cloud for supporting PaaS (Platform as a Service) <strong><u>services</u></strong>. In turn, the platform layer is a foundation for implementing the <strong><u>application</u></strong> layer for SaaS applications. </p><p>The infrastructure layer is built with virtualized compute, <strong><u>storage</u></strong>, and network resources. The abstraction of these hardware <strong><u>resources</u></strong> is meant to provide the flexibility demanded by users. Internally, virtualization realizes <strong><u>automated</u></strong> provisioning of resources and optimizes the infrastructure management process. The <strong><u>platform</u></strong> layer is for general-purpose and repeated usage of the collection of <strong><u>software</u></strong> resources. This layer provides users with an environment to <strong><u>develop</u></strong> their applications, to test operation flows, and to monitor execution <strong><u>results</u></strong> and performance. In a way, the virtualized cloud platform <strong><u>serves</u></strong> as a “system middleware (中间件)” between the infrastructure and application layers of the <strong><u>cloud</u></strong>. The application layer is formed with a collection of all needed software modules for <strong><u>SaaS</u></strong> applications. Service applications in this layer include daily office <strong><u>management</u></strong> work. The application layer is also heavily used by enterprises in business <strong><u>marketing</u></strong> and sales, consumer relationship management, financial transactions, and supply chain management.</p><h3 id="翻译-4"><a href="#翻译-4" class="headerlink" title="翻译"></a>翻译</h3><p>云计算动态供应硬件、软件和数据集，以此方式按需应用一个拥有弹性资源的虚拟化平台。其目的是通过在数据中心使用服务器集群和巨型数据库而将桌面计算转移到一个面向服务的平台。云计算充分利用其低成本与简单的特性既惠及用户也惠及提供商。机器虚拟化使这样的成本效益成为可能。云计算意在同时满足许多用户应用程序的需要。云生态系统必须设计得具有安全性、可信性和可靠性。有些计算机用户将云视为一个集中式资源池，而另外一些计算机用户则认为云是一个在所用的各个服务器上实行分布式计算的服务器集群。</p><p>传统上，一个分布式计算系统往往由一个自主管理域（如一个研究实验室或公司）为内部计算需要而拥有和使用。然而，这些传统系统遭遇数个性能瓶颈：系统维护需要不断进行；利用率差；与硬件／软件升级有关的费用日益增长。作为一种按需计算范式，云计算可解决这些问题或可使我们摆脱这些问题。</p><h2 id="Unit-10"><a href="#Unit-10" class="headerlink" title="Unit 10"></a>Unit 10</h2><h3 id="短语翻译-4"><a href="#短语翻译-4" class="headerlink" title="短语翻译"></a>短语翻译</h3><ol><li><p>backup system 备份系统</p></li><li><p>encryption key （加密）密钥</p></li><li><p>data confidentiality 数据机密性</p></li><li><p>system vulnerability 系统脆弱性，系统脆弱之处</p></li><li><p>unauthorized access 未经授权的访问，越权存取</p></li><li><p>intrusion detection system 入侵检测系统</p></li><li><p>after-action recovery 事后恢复</p></li><li><p>software piracy 软件侵权</p></li><li><p>authorized user 特许用户</p></li><li><p>data unit 数据单元，数据单位</p></li><li><p>软件版本 software version</p></li><li><p>数据完整性 data integrity</p></li><li><p>系统崩溃 system crash</p></li><li><p>病毒检查软件 virus-checking software</p></li><li><p>综合安全策略 comprehensive security strategy</p></li><li><p>软件配置管理 software configuration management </p></li><li><p>故障隔离 fault isolation</p></li><li><p>统计数据库 statistical database</p></li><li><p>保密的加密算法 secure encryption algorithm</p></li><li><p>数据流 data stream</p></li></ol><h3 id="完型填空-4"><a href="#完型填空-4" class="headerlink" title="完型填空"></a>完型填空</h3><p>An access control mechanism mediates between a user (or a process executing on behalf of a user) and system <strong><u>resources</u></strong>, such as applications, operating systems, firewalls, routers, files, and databases. The <strong><u>system</u></strong> must first authenticate (验证) a user seeking access. Typically the <strong><u>authentication</u></strong> function determines whether the user is permitted to <strong><u>access</u></strong> the system at all. Then the access control <strong><u>function</u></strong> determines if the specific requested access by this <strong><u>user</u></strong> is permitted. A security administrator maintains an authorization (授权) <strong><u>database</u></strong> that specifies what type of access to which resources is <strong><u>allowed</u></strong> for this user. The access control function consults this database to <strong><u>determine</u></strong> whether to grant access. An auditing function monitors and keeps a <u><strong>record</strong></u> of user accesses to system resources.</p><p>In practice, a number of <strong><u>components</u></strong> may cooperatively share the access control function. All <strong><u>operating</u></strong> systems have at least a rudimentary (基本的), and in many cases a quite <strong><u>robust</u></strong>, access control component. Add-on security packages can add to the <strong><u>native</u></strong> access control capabilities of the OS. Particular applications or <strong><u>utilities</u></strong>, such as a database management system, also incorporate access <strong><u>control</u></strong> functions. External devices, such as firewalls, can also provide access control services.</p><p>访问控制机制在用户（或代表用户执行的进程）和系统资源（如应用程序、操作系统、防火墙、路由器、文件和数据库）之间进行中介。系统必须首先对寻求访问的用户进行身份验证。通常，身份验证功能确定是否允许用户访问系统。然后访问控制功能确定是否允许此用户请求的特定访问。安全管理员维护一个授权（authorization）数据库，该数据库指定允许此用户访问哪些资源的访问类型。访问控制函数将查询此数据库以确定是否授予访问权限。审计功能监视并记录用户对系统资源的访问。       在实践中，多个组件可以协作地共享访问控制功能。所有的操作系统都至少有一个基本的，并且在许多情况下都有一个相当健壮的访问控制组件。附加安全包可以添加到操作系统的本机访问控制功能中。特定的应用程序或实用程序（如数据库管理系统）也包含访问控制功能。外部设备（如防火墙）也可以提供访问控制服务。</p><h3 id="翻译-5"><a href="#翻译-5" class="headerlink" title="翻译"></a>翻译</h3><p>入侵者攻击从温和的到严重的形形色色。在这一系列攻击的温和端，有许多人只是希望探查互联网，看看那里有什么。在严重端的是试图阅读特许数据、对数据进行未经授权的修改或扰乱系统的个人。</p><p>入侵者的目标是获得进入一个系统的机会，或者增加在一个系统中可以使用的特权范围。初始攻击大多利用系统或软件的脆弱之处，这些脆弱之处允许用户执行相应的代码，打开进入系统的后门。入侵者可对具有某些运行特权的程序实施像缓存溢出这样的攻击，利用此类攻击获得进入一个系统的机会。</p><p>另外，入侵者也试图获取应予保护的信息。在有些情况下，这种信息是以用户口令的形式存在的。知道了某个其他用户的口令之后，入侵者就可以登录系统并行使赋予合法用户的所有特权.</p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解与反射</title>
      <link href="2019/09/07/fan-she-yu-zhu-jie/"/>
      <url>2019/09/07/fan-she-yu-zhu-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h1><blockquote><p>这一章节对理解框架十分重要，包括接下来的Spring、Mybatis</p><p>文章参考以下内容，转载或引用请注明原作者和引用文章</p><p><a href="https://www.bilibili.com/video/BV1p4411P7V3" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1p4411P7V3</a></p></blockquote><h2 id="注解（Annotation）"><a href="#注解（Annotation）" class="headerlink" title="注解（Annotation）"></a>注解（Annotation）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>注解是JDK 5.0开始引入技术（Annotation）</li><li>注解的作用<ul><li>对程序作介绍（注释是对人来用的）</li><li>被其他程序使用</li></ul></li></ul><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul><li><p>@Override</p><ul><li>在Java.lang.Override，声明重写超类后的第二个方法，作用范围：方法</li></ul></li><li><p>@Deprecated</p><ul><li>作用范围：方法，属性，类</li><li>表示不推荐使用此元素</li></ul></li><li><p>@SuppressWarnings</p><ul><li>用来抑制编译警告</li><li>与前俩个不同的是，此注解需要添加一个参数<ul><li>@SuppressWarnings(“all”)</li><li>@SuppressWarnings(“unchecked”)</li><li>@SuppressWarnings(value ={“unchecked”,”deprecation”})</li><li>…..</li></ul></li></ul></li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul><li><p>作用：负责注解其他注解，Java定义了四个标准类型</p></li><li><p>这些类型和它们所支持的类在Java.lang.Override包中可以找到 .( @Target , @Retention ,@Documented , @Inherited )</p><ul><li>@Target：描述注解使用范围,所有范围如下<ul><li><img src="/2019/09/07/fan-she-yu-zhu-jie/image-20200630211230803.png" class=""></li></ul></li><li>@Retention : 表示需要在什么级别保存该注释信息 , 用于描述注解的生命周期<ul><li>(SOURCE &lt; CLASS &lt; RUNTIME)</li></ul></li><li>@Document：说明该注解将被包含在Javadoc中</li><li>@Inherited：说明子类可以继承父类中的该注解J</li></ul></li></ul><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ul><li>使用 @interface自定义注解时 , 自动继承了java.lang.annotation.Annotation接口</li><li>分析<ul><li>@ interface用来声明一个注解 , 格式 : public @ interface 注解名 { 定义内容 }<ul><li>若public不写默认为default</li></ul></li><li>其中的每一个方法实际上是声明了一个配置参数.</li><li>方法的名称就是参数的名称.</li><li>返回值类型就是参数的类型 ( 返回值只能是基本类型,Class , String , enum ).</li><li><strong>如果只有一个参数成员 , 一般参数名为value，通常这个参数名不需要在使用注解时表明</strong></li><li>注解元素必须要有值 , 我们定义注解元素时 , 经常使用空字符串,0作为默认值 .</li><li>当默认值为-1时表示不存在</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test3</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@MyAnnotation1</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"CodeForce"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>@<span class="token keyword">interface</span> <span class="token class-name">MyAnnotation1</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span><span class="token comment" spellcheck="true">//-1代表不存在   等同于字符串的indexof()返回-1</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="反射读取注解"><a href="#反射读取注解" class="headerlink" title="反射读取注解"></a><strong>反射读取注解</strong></h3><p>利用反射读取注解信息三步骤：</p><ol><li>定义注解</li><li>在类中使用注解</li><li>使用反射获取注解，一般此步骤都由框架集成，以下手动实现</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test5</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> NoSuchFieldException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过反射获取类全部信息，所有东西</span>        Class <span class="token class-name">c1</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//得到这个类的注解</span>        Annotation<span class="token punctuation">[</span><span class="token punctuation">]</span> annotations <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Annotation annotation <span class="token operator">:</span> annotations<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//获得类的注解value值</span>        OnTable annotation <span class="token operator">=</span> <span class="token punctuation">(</span>OnTable<span class="token punctuation">)</span> c1<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>OnTable<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotation<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获得类指定注解的值</span>        Field name <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        OnFiled onFiled <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>OnFiled<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>onFiled<span class="token punctuation">.</span><span class="token function">columnName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"---"</span><span class="token operator">+</span>onFiled<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"---"</span><span class="token operator">+</span>onFiled<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//此方法就是通过得到信息,在JDBC生成相关SQL语句</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@OnTable</span><span class="token punctuation">(</span><span class="token string">"db_person"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@OnFiled</span><span class="token punctuation">(</span>columnName <span class="token operator">=</span> <span class="token string">"db_name"</span><span class="token punctuation">,</span>type <span class="token operator">=</span> <span class="token string">"varchar"</span><span class="token punctuation">,</span>length <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Person{"</span> <span class="token operator">+</span>                <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>value <span class="token operator">=</span> RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>@<span class="token keyword">interface</span> <span class="token class-name">OnFiled</span><span class="token punctuation">{</span>    String <span class="token function">columnName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//列名</span>    String <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//类型</span>    <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//长度</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>value <span class="token operator">=</span> RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>@<span class="token keyword">interface</span> <span class="token class-name">OnTable</span><span class="token punctuation">{</span>   String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//只有一个推荐使用value</span><span class="token punctuation">}</span></code></pre><h2 id="反射（Reflection）"><a href="#反射（Reflection）" class="headerlink" title="反射（Reflection）"></a>反射（Reflection）</h2><h3 id="动态语言与静态语言："><a href="#动态语言与静态语言：" class="headerlink" title="动态语言与静态语言："></a>动态语言与静态语言：</h3><ul><li>Java虽然作为静态语言，但是利用反射机制使得Java拥有部分动态语言的特性</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><pre class=" language-java"><code class="language-java">Class <span class="token class-name">c</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.util.List"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</p>{% asset_img image-20200630220318565.png %}<h4 id="Java反射提供的功能"><a href="#Java反射提供的功能" class="headerlink" title="Java反射提供的功能"></a>Java反射提供的功能</h4><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解(框架注解开发的原理)</li><li>生成动态代理</li><li>…….</li></ul><h4 id="Java反射优点和缺点"><a href="#Java反射优点和缺点" class="headerlink" title="Java反射优点和缺点"></a>Java反射优点和缺点</h4><p>优点：可以实现动态创建对象和编译，体现出很大的灵活性 !</p><p>缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p><h3 id="反射相关的主要API"><a href="#反射相关的主要API" class="headerlink" title="反射相关的主要API"></a>反射相关的主要API</h3><ul><li>java.lang.Class : 代表一个类</li><li>java.lang.reflect.Method : 代表类的方法</li><li>java.lang.reflect.Field : 代表类的成员变量</li><li>java.lang.reflect.Constructor : 代表类的构造器</li><li>……</li></ul><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>如果还得的话，Object作为所有类的基类有个getClass()方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。</p><img src="/2019/09/07/fan-she-yu-zhu-jie/image-20200630221148276.png" class=""><p>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，<strong>JRE 都为其保留一个不变的 Class 类型的对象</strong>。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。</p><ul><li>Class 本身也是一个类</li><li>Class 对象只能由系统建立对象</li><li>一个加载的类在 JVM 中只会有一个Class实例</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li><li>通过Class可以完整地得到一个类中的所有被加载的结构</li><li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li></ul><p>获取class几种方式</p><img src="/2019/09/07/fan-she-yu-zhu-jie/image-20200630221436391.png" class=""><p><strong>还有一种利用类加载器在下文中会提到</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="center">static ClassforName(String name)</td><td align="center">返回指定类名name的Class对象</td></tr><tr><td align="center">Object newInstance()</td><td align="center">调用缺省构造函数，返回Class对象的一个实例</td></tr><tr><td align="center">getName()</td><td align="center">返回此Class对象所表示的实体（类，接口，数组类或void）的名称。</td></tr><tr><td align="center">Class getSuperClass()</td><td align="center">返回当前Class对象的父类的Class对象</td></tr><tr><td align="center">Class[] getinterfaces()</td><td align="center">获取当前Class对象的接口</td></tr><tr><td align="center">ClassLoader getClassLoader()</td><td align="center">返回该类的类加载器</td></tr><tr><td align="center">Constructor[] getConstructors()</td><td align="center">返回一个包含某些Constructor对象的数组Method getMothed(</td></tr><tr><td align="center">Method getMothed(Stringname,Class.. T)</td><td align="center">返回一个Method对象，此对象的形参类型为paramType</td></tr><tr><td align="center">Field[] getDeclaredFields()</td><td align="center">返回Field对象的一个数组</td></tr></tbody></table><h3 id="哪些类型可以有class对象"><a href="#哪些类型可以有class对象" class="headerlink" title="哪些类型可以有class对象"></a>哪些类型可以有class对象</h3><ul><li>class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。</li><li>interface：接口</li><li>[]：数组</li><li>enum：枚举</li><li>annotation：注解@interface</li><li>primitive type：基本数据类型</li><li>void</li></ul><blockquote><h6 id="这里要注意一点的是数组只要元素类型与维度一样，就是同一个class"><a href="#这里要注意一点的是数组只要元素类型与维度一样，就是同一个class" class="headerlink" title="这里要注意一点的是数组只要元素类型与维度一样，就是同一个class"></a>这里要注意一点的是数组只要元素<strong>类型</strong>与<strong>维度</strong>一样，就是同一个class</h6></blockquote><h3 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h3><img src="/2019/09/07/fan-she-yu-zhu-jie/image-20200630222933913.png" class=""><h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><img src="/2019/09/07/fan-she-yu-zhu-jie/image-20200630223356676.png" class=""><h4 id="类的加载与ClassLoader的理解"><a href="#类的加载与ClassLoader的理解" class="headerlink" title="类的加载与ClassLoader的理解"></a>类的加载与ClassLoader的理解</h4><ul><li>加载<ul><li>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象.</li></ul></li><li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul><li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li><li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li><li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li></ul></li><li>初始化：<ul><li>执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。</li></ul></li></ul><h4 id="什么时候会发生类初始化？"><a href="#什么时候会发生类初始化？" class="headerlink" title="什么时候会发生类初始化？"></a>什么时候会发生类初始化？</h4><ul><li><p>类的主动引用（一定会发生类的初始化）</p><ul><li>main在虚拟机启动时的初始化</li><li>new 一个类的对象</li><li><strong>调用类的静态成员（除了final常量）和静态方法</strong></li><li>对类进行反射调用</li><li>当初始化一个类，如果父类没有被初始化，则会先初始化它的父类</li></ul></li><li><p><strong>类的被动引用（不会发生类的初始化）</strong></p><ul><li><p>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</p></li><li><p>通过数组定义类引用，不会触发此类的初始化</p><pre class=" language-java"><code class="language-java">类名<span class="token punctuation">[</span><span class="token punctuation">]</span> 名称 <span class="token operator">=</span> <span class="token keyword">new</span> 类名<span class="token punctuation">[</span>数量<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不会初始化此类</span></code></pre></li><li><p>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</p></li></ul></li></ul><h4 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h4><ul><li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问<strong>入口</strong>。</li><li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</li></ul>{% asset_img image-20200630231710334.png %}<ul><li>类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器</li></ul>{% asset_img image-20200630231743009.png %}<h3 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h3><p>通过反射获取运行时类的完整结构<br>Field、Method、Constructor、Superclass、Interface、Annotation</p><ul><li>实现的全部接口</li><li>所继承的父类</li><li>全部的构造器</li><li>全部的方法</li><li>全部的Field</li><li>注解</li><li>……</li></ul><h3 id="有了Class对象，能做什么事情"><a href="#有了Class对象，能做什么事情" class="headerlink" title="有了Class对象，能做什么事情"></a>有了Class对象，能做什么事情</h3><ul><li>创建类的对象：调用Class对象的newInstance()方法<ul><li>类必须有一个无参数的构造器。</li><li>类的构造器的访问权限需要足够</li></ul></li><li>若没有无参构造器，则按照以下方式创建<ul><li>通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器</li><li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li><li>通过Constructor实例化对象</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//c1是类getclass得来的</span><span class="token comment" spellcheck="true">//无参构造</span>Person person <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span>c1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有参构造</span>Constructor constructor <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Person person1 <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"CodeForce"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="调用指定方法"><a href="#调用指定方法" class="headerlink" title="调用指定方法"></a>调用指定方法</h4><ul><li><p>通过反射，调用类中的方法，通过Method类完成。</p><ul><li><p>通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</p></li><li><p>之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。</p><img src="/2019/09/07/fan-she-yu-zhu-jie/image-20200630233852371.png" class=""></li></ul></li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//通过反射获取一个方法(反射操作方法)</span>    Method setName <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"setName"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    setName<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token string">"Code"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><p>Object 对应原方法的返回值，若原方法无返回值，此时返回null</p></li><li><p>若原方法若为静态方法，此时形参Object obj可为null</p></li><li><p>若原方法形参列表为空，则Object[] args为null</p></li><li><p><strong>若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的</strong><br><strong>setAccessible(true)方法，将可访问private的方法。</strong></p><pre class=" language-java"><code class="language-java">Field name <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//name作为private属性，正常不能直接访问，可通过setAccessible关闭检测</span>name<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>name<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token string">"code1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="setAccessible"><a href="#setAccessible" class="headerlink" title="setAccessible"></a>setAccessible</h3><ul><li>Method和Field、Constructor对象都有setAccessible()方法。</li><li>setAccessible作用是启动和禁用访问安全检查的开关。</li><li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。</li><li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</li><li>使得原本无法访问的私有成员也可以访问</li><li>参数值为false则指示反射的对象应该实施Java语言访问检查</li></ul><h3 id="反射操作泛型"><a href="#反射操作泛型" class="headerlink" title="反射操作泛型"></a>反射操作泛型</h3><ul><li>Java采用泛型擦除的机制来引入泛型 , Java中的泛型仅仅是给编译器javac使用的,确保数据的安全性和免去强制类型转换问题 , 但是 , 一旦编译完成 , 所有和泛型有关的类型全部擦除</li><li>为了通过反射操作这些类型 , Java新增了 ParameterizedType , GenericArrayType , TypeVariable和 WildcardType 几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型.</li><li>ParameterizedType : 表示一种参数化类型,比如Collection</li><li>GenericArrayType : 表示一种元素类型是参数化类型或者类型变量的数组类型</li><li>TypeVariable : 是各种类型变量的公共父接口</li><li>WildcardType : 代表一种通配符类型表达式</li></ul><h3 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h3><p>详情请看反射读取注解那段</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
